/**
 * DO NOT EDIT
 * -- this file is generated by minipbjs v0.2.5
 */

const protobuf = require("protobufjs/minimal") ;
protobuf.util.Long = require('long');
var $root = protobuf.roots;

// type system from protobuf
// notice: minimal build protobuf library does not contains 'types'
var $wires = protobuf.types ? protobuf.types.basic : { 'double': 1, 'float': 5, 'int32': 0, 'uint32': 0, 'sint32': 0, 'fixed32': 5, 'sfixed32': 5, 'int64': 0, 'uint64': 0, 'sint64': 0, 'fixed64': 1, 'sfixed64': 1, 'bool': 0, 'string': 2, 'bytes': 2 };
var $packed = protobuf.types ? protobuf.types.packed : { 'double': 1, 'float': 5, 'int32': 0, 'uint32': 0, 'sint32': 0, 'fixed32': 5, 'sfixed32': 5, 'int64': 0, 'uint64': 0, 'sint64': 0, 'fixed64': 1, 'sfixed64': 1, 'bool': 0 };
var $types = Object.keys($wires);

function invalid({ name, repeated, map, keyType }, expected) {
    return name + ': ' + expected + (repeated && expected !== 'array' ? '[]' : map && expected !== 'object' ? '{k:'+keyType+'}' : '') + ' expected';
}
var keyVerifyMap = { int32: 'key32Re', uint32: 'key32Re', sint32: 'key32Re', fixed32: 'key32Re', sfixed32: 'key32Re', int64: 'key64Re', uint64: 'key64Re', sint64: 'key64Re', fixed64: 'key64Re', sfixed64: 'key64Re', bool: 'key2Re' };
function verifyKey(type, message, fieldInfo) {
    if (keyVerifyMap[type]) {
        if (!protobuf.util[keyVerifyMap[type]].test(message)) {
            fieldInfo.keyType = type;
            return invalid(fieldInfo, 'key')
        }
        return null;
    }
    return null;
};
var type32Map = { int32: 1, uint32: 1, sint32: 1, fixed32: 1, sfixed32: 1 };
var type64Map = { int64: 1, uint64: 1, sint64: 1, fixed64: 1, sfixed64: 1 };
var floatOrDoubleMap = { float: 1, double: 1 };
var util = protobuf.util;

var $verifier = {
    '$': function(type, message, fieldInfo, field) {
        if (field === '$1') {
            fieldInfo.map = true;
            return verifyKey(type, message, fieldInfo);
        }
        // basic type
        if ($wires[type] !== undefined) {
            if (type32Map[type]) {
                if (typeof message !== 'number') return invalid(fieldInfo, 'number');
            } else if (type64Map[type]) {
                if (!util.isInteger(message) && !(message && util.isInteger(message.low) && util.isInteger(message.high))) {
                    return invalid(fieldInfo, 'integer|Long');
                }
            } else if (floatOrDoubleMap[type]) {
                if (typeof message !== 'number') return invalid(fieldInfo, 'float|double');
            } else if (type === 'bool') {
                if (typeof message !== 'boolean') return invalid(fieldInfo, 'boolean');
            } else if (type === 'string') {
                if (!util.isString(message)) return invalid(fieldInfo, 'string');
            } else if (type === 'bytes') {
                if(!(message && typeof message.length ==='number' || util.isString(message))) {
                    return invalid(fieldInfo, 'invalid bytes');
                }
            }
            return null;
        }
        if ($root[type].resolvedType) return $root[type].resolvedType[message] ? null : invalid(fieldInfo, 'enum value');
        return $root[type].verify(message);
    },
};
// wrappers
var $reader = {
    '$': function(type) {
        if ($reader[type]) {
            return $reader[type].call(this);
        }
        return $root[type].decode(this, this.uint32());
    }
}, $writer = {
    '$': function(type, message, id) {
        var wire = $wires[type];
        if (wire === undefined) {
            this.uint32((id << 3 | 2) >> 0).fork();
            return $root[type].encode(message, this).ldelim();
        }
        return $writer[type].call(this.uint32(id << 3 | wire), message);
    }
};

for (var i = 0; i < $types.length; i ++) {
    $reader[$types[i]] = protobuf.Reader.prototype[$types[i]];
    $writer[$types[i]] = protobuf.Writer.prototype[$types[i]];
}

function $createConverter(cfgs) {
    var converter = {};
    for (var i = 0; i < cfgs.length; i ++) {
        var cfg = cfgs[i];
        for (var j = 0; j < cfg.types.length; j ++) {
            converter[cfg.types[j]] = cfg.convf;
        }
    }
    return converter;
}

// fromObject
var $conv_object = $createConverter([
    {
        'types': [ 'bool' ],
        'convf': Boolean
    }, {
        'types': [ 'string' ],
        'convf': String
    }, {
        'types': [ 'float', 'double' ],
        'convf': Number
    }, {
        'types': [ 'uint32', 'fixed32' ],
        'convf': function(value) { return value >>> 0; }
    }, {
        'types': [ 'int32', 'sint32', 'sfixed32' ],
        'convf': function(value) { return value | 0; }
    }, {
        'types': [ 'int64', 'sint64', 'fixed64', 'sfixed64', 'uint64' ],
        'convf': function(value, type) {
            var ret = undefined;
            if (protobuf.util.Long) {
                ret = protobuf.util.Long.fromValue(value);
                ret.unsigned = type.charAt(0) === 'u';
            } else if (typeof value === 'object') {
                ret = new protobuf.util.LongBits(value.low >>> 0, value.high >>> 0).toNumber(type.charAt(0) === 'u');
            } else if (typeof value === 'string') {
                ret = parseInt(value, 10);
            } else if (typeof value === 'number') {
                ret = value;
            }
            return ret;
        }
    }, {
        'types': [ 'bytes' ],
        'convf': function(value, type) {
            var ret = undefined;
            if (typeof value === 'string') {
                ret = protobuf.util.newBuffer(protobuf.util.base64.length(value))
                protobuf.util.base64.decode(value, ret, 0);
            } else if (value.length) {
                ret = value;
            }
            return ret;
        }
    }, {
        'types': [ '$' ],
        'convf': function(value, type) {
            if ($conv_object[type]) {
                return $conv_object[type].call(null, value, type);
            } else if (!$root[type].fromObject) {
                // enum
                var ret = $root[type][value];
                return typeof ret === 'string' ? $root[type][ret] : ret;
            }
            return $root[type].fromObject(value);
        }
    }
]);

// toObject
var $conv_message = $createConverter([
    {
        'types': [ 'float', 'double' ],
        'convf': function(value, type, options) {
            return options.json && !isFinite(value) ? String(value) : value;
        }
    }, {
        'types': [ 'int64', 'sint64', 'fixed64', 'sfixed64', 'uint64' ],
        'convf': function(value, type, options) {
            if (typeof value === 'number') {
                return options.longs === String ? String(value) : value;
            }
            if (options.longs === String) {
                return protobuf.util.Long.prototype.toString.call(value);
            } else if (options.longs === Number) {
                return new protobuf.util.LongBits(value.low >>> 0, value.high >>> 0).toNumber(type.charAt(0) === 'u');
            }
            return value;
        }
    }, {
        'types': [ 'bytes' ],
        'convf': function(value, type, options) {
            if (options.bytes === String) {
                return protobuf.util.base64.encode(value, 0, value.length);
            } else if (options.bytes === Array) {
                return Array.prototype.slice.call(value);
            }
            if (Array.isArray(value)) {
                return protobuf.util.newBuffer(value);
            }
            return value;
        }
    }, {
        'types': [ '$' ],
        'convf': function(value, type, options) {
            if ($conv_message[type]) {
                return $conv_message[type].call(null, value, type, options);
            } else if ($wires[type] === undefined) {
                if ($root[type].toObject) {
                    return $root[type].toObject(value, options);
                }
                // enum
                return options.enums === String ? $root[type][value] : value;
            }
            return value;
        }
    }
]);

// namespace builder
(function _(namespace, path, parent, inner) {
    for (var i = 0, keys = Object.keys(namespace); i < keys.length; i ++) {
        var key = keys[i];
        if (namespace[key]['$'] && Object.keys(namespace[key]['$']).every(function(k) { return Number(k); })) {
            // protobuf.type
            if (parent[key]) throw Error('field ' + path + '.' + key + ' has already existed');
            parent[key] = function(payloads, key) {
                /**
                 * Constructor function wrapper for the all protobuf type.
                 * @constructor
                 * @param [props] Properties to set with
                 */
                function C(props) {
                    for (var id in payloads) {
                        var payload = payloads[id];
                        // initialize object/array fields
                        if (payload[1].charAt(0) === '{') {
                            this[payload[0]] = {};
                        } else if (payload[1].charAt(0) === '[' || payload[1].charAt(0) === '<') {
                            this[payload[0]] = [];
                            }
                        }
                        if (props) {
                            for (var keys = Object.keys(props), i = 0; i < keys.length; ++i) {
                                props[keys[i]] != null && (this[keys[i]] = props[keys[i]]);
                        }
                    }
                }

                // set prototypes and collect inner namespace for map fields
                var $namespace = {};
                for (var id in payloads) {
                    var payload = payloads[id];
                    var type = payload[1];
                    if (type.charAt(0) === '{') {
                        C.prototype[payload[0]] = protobuf.util.emptyObject;
                        // collect all map fields
                        // { key: value } => { '1': [ '$1', <key>, null ], '2': [ '$2', <value>, null ] }
                        $namespace[type] = {
                            '$': type.substring(1).split(',')
                                .map(function(t, i) { return ['$' + (i + 1), t, null] })
                                .reduce(function(m, o, i) { m[i + 1] = o; return m; }, {})
                        };
                    } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                        C.prototype[payload[0]] = protobuf.util.emptyArray;
                    } else if (type === 'bytes') {
                        C.prototype[payload[0]] = protobuf.util.newBuffer([]);
                    } else {
                        if (payload[2] && payload[2].hasOwnProperty('low') && payload[2].hasOwnProperty('high')) {
                            C.prototype[payload[0]] = protobuf.util.Long.fromBits(payload[2].low, payload[2].high, payload[2].unsigned);
                        } else {
                            C.prototype[payload[0]] = payload[2];
                        }
                    }
                }

                /**
                 * Creates a new instance using the specified properties.
                 * @function create
                 * @static
                 * @param [props] Properties to set with
                 * @returns {C} instance
                 */
                C.create = function(props) {
                    return new parent[key](props);
                };

                /**
                 * Decodes a message from the specified reader or buffer.
                 * @function decode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} length Message length if known beforehand
                 * @returns {C} instance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                C.decode = function(reader, length) {
                    if (!(reader instanceof protobuf.Reader)) reader = protobuf.Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length;
                    var message = new parent[key]();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        var id = tag >>> 3;
                        if (id > 0 && payloads[id]) {
                            var field = payloads[id][0];
                            var type = payloads[id][1];
                            if (type.charAt(0) === '{') {
                                // map field
                                if (message[field] === protobuf.util.emptyObject) {
                                    message[field] = {};
                                }
                                // decode map fields from inner namespace
                                var $message = parent[key].$namespace[type].decode(reader, reader.uint32());
                                message[field][$message['$1']] = $message['$2'];
                            } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                                // repeated field
                                type = type.substring(1);
                                if (!(message[field] && message[field].length)) {
                                    message[field] = [];
                                }
                                if ($packed[type] !== undefined && (tag & /*2^3-1=*/7) === 2) {
                                    // packed repeated
                                    var $end = reader.uint32() + reader.pos;
                                    while (reader.pos < $end) {
                                        message[field].push($reader['$'].call(reader, type));
                                    }
                                } else {
                                    message[field].push($reader['$'].call(reader, type));
                                }
                            } else {
                                // non-repeated field
                                message[field] = $reader['$'].call(reader, type);
                            }
                        } else {
                            // unknown field
                            reader.skipType(tag & /*2^3-1=*/7);
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} length Message length if known beforehand
                 * @returns {C} instance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                C.decodeDelimited = function(reader) {
                    if (!(reader instanceof protobuf.Reader)) reader = protobuf.Reader.create(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Encodes the specified C message. Does not implicitly verify messages.
                 * @function encode
                 * @static
                 * @param {C} message or plain object to encode
                 * @param {$protobuf.Writer} writer Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                C.encode = function(message, writer) {
                    if (!writer) writer = protobuf.Writer.create();
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        if (type.charAt(0) === '{') {
                            // map field
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                for (var i = 0, keys = Object.keys(message[field]); i < keys.length; ++ i) {
                                    writer.uint32((id << 3 | 2) >> 0).fork();
                                    // encode map fields from inner namespace
                                    parent[key].$namespace[type].encode({ '$1': keys[i], '$2': message[field][keys[i]] }, writer).ldelim();
                                }
                            }
                        } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                            // repeated field
                            var packed = type.charAt(0) === '<';
                            type = type.substring(1);
                            var array = message[field];
                            if (array != null && array.length) {
                                if (packed && $packed[type] !== undefined) {
                                    // packed repeated
                                    writer.uint32((id << 3 | 2) >> 0).fork();
                                    for (var i = 0; i < array.length; i ++) {
                                        $writer[type].call(writer, array[i]);
                                    }
                                    writer.ldelim();
                                } else {
                                    for (var i = 0; i < array.length; i ++) {
                                        $writer['$'].call(writer, type, array[i], id);
                                    }
                                }
                            }
                        } else {
                            // non-repeated field
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                $writer['$'].call(writer, type, message[field], id);
                            }
                        }
                    }
                    return writer;
                };

                /**
                 * Encodes the specified C message, length delimited. Does not implicitly verify messages.
                 * @function encode
                 * @static
                 * @param {C} message or plain object to encode
                 * @param {$protobuf.Writer} writer Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                C.encodeDelimited = function(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Creates a C message from plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @param {C} message
                 */
                C.fromObject = function(object) {
                    if (object instanceof parent[key]) return object;
                    var message = new parent[key]();
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        var property = object[field];
                        if (type.charAt(0) === '{') {
                            // map field
                            if (!property) continue;
                            if (typeof property !== 'object') throw TypeError(path + '.' + key + '.' + field + ': object expected');
                            var map = {};
                            var vtype = type.substring(1).split(',')[1];
                            for (var i = 0, keys = Object.keys(property); i < keys.length; ++ i) {
                                map[keys[i]] = $conv_object['$'].call(null, property[keys[i]], vtype);
                            }
                            message[field] = map;
                        } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                            // repeated field
                            if (!property) continue;
                            if (!Array.isArray(property)) throw TypeError(path + '.' + key + '.' + type + ': arary excepted');
                            var array = [];
                            type = type.substring(1);
                            for (var i = 0; i < property.length; i ++) {
                                array[i] = $conv_object['$'].call(null, property[i], type);
                            }
                            message[field] = array;
                        } else {
                            // non-repeated field
                            if (property != null) {
                                message[field] = $conv_object['$'].call(null, property, type);
                            }
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a C message. Also converts values to other types if specified.
                 * @function toObject
                 * @static
                 * @param {C} message protobuf message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                C.toObject = function(message, options) {
                    options = options || {};
                    var object = {};
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        var property = message[field];
                        if (type.charAt(0) === '{') {
                            // map field
                            if (options.objects || options.defaults) {
                                object[field] = {};
                            }
                            var keys = property ? Object.keys(property) : [];
                            if (keys.length) {
                                var map = {};
                                var vtype = type.substring(1).split(',')[1];
                                for (var i = 0; i < keys.length; i ++) {
                                    map[keys[i]] = $conv_message['$'].call(null, property[keys[i]], vtype, options);
                                }
                                object[field] = map;
                            }
                        } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                            // repeated field
                            if (options.arrays || options.defaults) {
                                object[field] = [];
                            }
                            if (property && property.length) {
                                var array = [];
                                type = type.substring(1);
                                for (var i = 0; i < property.length; i ++) {
                                    array[i] = $conv_message['$'].call(null, property[i], type, options);
                                }
                                object[field] = array;
                            }
                        } else {
                            // non-repeated field
                            // TODO support for Enum type
                            if (options.defaults) {
                                object[field] = $conv_message['$'].call(null, payloads[id][2], type, options);
                            }
                            if (property != null && message.hasOwnProperty(field)) {
                                object[field] = $conv_message['$'].call(null, property, type, options);
                            }
                        }
                    }
                    return object;
                };

                /**
                 * Converts this C to JSON.
                 * @function toJSON
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                C.prototype.toJSON = function() {
                    return this.constructor.toObject(this, protobuf.util.toJSONOptions);
                };

                /**
                 * Verifies C message.
                 * @function verify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                C.verify = function(message) {
                    if (typeof message !=='object' || message === null) return 'object expected'
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        var fieldName = path + '.' + key + '.' + field;
                        if (type.charAt(0) === '{') {
                            // map field
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                if (!protobuf.util.isObject(message[field])) return invalid({ name: fieldName, map: true }, 'object');
                                var keys = Object.keys(message[field]);
                                for (var i = 0; i < keys.length; ++i) {
                                    parent[key].$namespace[type].$fieldName = fieldName
                                    var error = parent[key].$namespace[type].verify({ '$1': keys[i], '$2': message[field][keys[i]] });
                                    if (error) return error;
                                }
                            }
                        } else if (type.charAt(0) === '[' || type.charAt(0) === '<') {
                            // repeated field
                            type = type.substring(1);
                            var array = message[field];
                            if (!Array.isArray(array)) {
                                return invalid({ name: fieldName, repeated: true }, 'array')
                            }
                            for (var i = 0; i < array.length; i ++) {
                                var error = $verifier['$'](type, array[i], { name: fieldName + '['+i+']' , repeated: true });
                                if (error) return error;
                            }
                        } else {
                            // non-repeated field
                            if (field === '$1' || field === '$2') fieldName = this.$fieldName;
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                var error = $verifier['$'](type, message[field], { name: fieldName }, field);
                                if (error) return error;
                            }
                        }
                    }
                    return null;
                };

                // create inner namespace for each map field
                if (Object.keys($namespace).length) {
                    C.$namespace = _($namespace, path + '.' + key, C.$namespace || {}, true);
                }

                return C;
            }(namespace[key]['$'], key);

            // exposing non-inner type to $root
            !inner && ($root[path + '.' + key] = parent[key]);
        } else if (namespace[key]['@'] && Object.values(namespace[key]['@']).every(function(v) { return Number(v) === v; })) {
            // protobuf.enum
            parent[key] = function(payloads, key) {
                var keys = Object.keys(payloads);
                var values = {};
                for (var i = 0; i < keys.length; i ++) {
                    values[values[keys[i]] = payloads[keys[i]]] = keys[i];
                }
                var vals = {};
                keys.forEach(function (i) { vals[values[i]] = 1; });
                values.resolvedType = vals;
                return values;
            }(namespace[key]['@'], key);
            // exposing non-inner enum to $root
            !inner && ($root[path + '.' + key] = parent[key]);
        }
        // delete parsed type and enum
        delete namespace[key]['$'];
        delete namespace[key]['@'];
        parent[key] = _(namespace[key], path ? path + '.' + key : key, parent[key] || {});
    }
    return parent;
})({
    default: {
        PTP: {
            Auth: {
                AuthLoginReq: {
                    '$': {"1":["sign","string",""],"2":["clientInfo","default.PTP.Common.ClientInfo",null]}
                },
                AuthLoginRes: {
                    '$': {"100":["err","uint32",0]}
                },
                AuthNativeReq: {
                    '$': {"1":["accountId","uint64",{"low":0,"high":0,"unsigned":true}],"2":["entropy","string",""],"3":["session","string",""]}
                },
                AuthNativeRes: {
                    '$': {}
                },
                AuthPreLoginReq: {
                    '$': {"1":["sign1","bytes",[]],"2":["address1","string",""],"3":["sign2","bytes",[]],"4":["address2","string",""],"5":["ts","uint64",{"low":0,"high":0,"unsigned":true}]}
                },
                AuthPreLoginRes: {
                    '$': {"1":["uid","string",""],"2":["ts","uint64",{"low":0,"high":0,"unsigned":true}],"100":["err","uint32",0]}
                },
                AuthStep1Req: {
                    '$': {"1":["p","bytes",[]]}
                },
                AuthStep1Res: {
                    '$': {"1":["q","bytes",[]],"2":["address","string",""],"3":["sign","bytes",[]],"6":["ts","uint64",{"low":0,"high":0,"unsigned":true}],"100":["err","uint32",0]}
                },
                AuthStep2Req: {
                    '$': {"1":["ts","uint64",{"low":0,"high":0,"unsigned":true}],"2":["address","string",""],"3":["sign","bytes",[]]}
                },
                AuthStep2Res: {
                    '$': {"100":["err","uint32",0]}
                },
                InitAppRes: {
                    '$': {"1":["chats","string",""],"2":["messages","string",""],"3":["chatFolders","string",""],"4":["users","string",""],"5":["topCats","string",""],"100":["err","uint32",0]}
                },
                UpdateProfileReq: {
                    '$': {"1":["firstName","string",""],"2":["lastName","string",""],"3":["about","string",""]}
                },
                UpdateProfileRes: {
                    '$': {"100":["err","uint32",0]}
                },
                UpdateUsernameReq: {
                    '$': {"1":["username","string",""]}
                },
                UpdateUsernameRes: {
                    '$': {"100":["err","uint32",0]}
                },
                UploadProfilePhotoReq: {
                    '$': {"1":["id","string",""],"2":["is_video","bool",false],"3":["thumbnail","string",""]}
                },
                UploadProfilePhotoRes: {
                    '$': {"1":["payload","string",""],"100":["err","uint32",0]}
                }
            },
            Chats: {
                LoadChatsReq: {
                    '$': {"1":["limit","uint32",0],"2":["offsetDate","uint32",0],"3":["archived","bool",false],"4":["withPinned","bool",false],"5":["lastLocalServiceMessage","string",""]}
                },
                LoadChatsRes: {
                    '$': {"1":["payload","string",""],"100":["err","uint32",0]}
                }
            },
            Common: {
                AUTH_TYPE: {
                    '@': {"AUTH_TYPE_USERNAME":0,"AUTH_TYPE_EMAIL":1,"AUTH_TYPE_MOBILE":2}
                },
                ChatGptStreamStatus: {
                    '@': {"ChatGptStreamStatus_START":0,"ChatGptStreamStatus_GOING":1,"ChatGptStreamStatus_DONE":2,"ChatGptStreamStatus_ERROR":3}
                },
                ClientInfo: {
                    '$': {"1":["deviceModel","string",""],"2":["systemVersion","string",""],"3":["appVersion","string",""]}
                },
                EncryptType: {
                    '@': {"EncryptType_Wallet":0,"EncryptType_Group":1,"EncryptType_Message":2,"EncryptType_Media":3}
                },
                ERR: {
                    '@': {"NO_ERROR":0,"ERR_SYSTEM":1,"ERR_AUTH_LOGIN":2,"ERR_AUTH_NEED":3,"ERR_NOT_FOUND":4}
                },
                FileInfo: {
                    '$': {"1":["id","string",""],"2":["size","uint64",{"low":0,"high":0,"unsigned":true}],"3":["part","uint32",0],"4":["part_total","uint32",0],"5":["buf","bytes",[]],"6":["type","string",""]}
                },
                MessageStoreRow: {
                    '$': {"1":["messageId","uint32",0],"2":["buf","bytes",[]]}
                },
                MsgRow: {
                    '$': {"1":["text","string",""],"2":["msgId","uint32",0],"3":["chatId","string",""],"4":["senderId","string",""],"5":["msgDate","uint32",0]}
                },
                PbAction: {
                    '$': {"1":["text","string",""],"2":["type","string",""]}
                },
                PbAiBot: {
                    '$': {"1":["chatGptConfig","default.PTP.Common.PbChatGpBotConfig",null],"3":["enableAi","bool",false],"4":["botApi","string",""],"5":["disableClearHistory","bool",false],"6":["commandsFromApi","<default.PTP.Common.PbCommands",null]}
                },
                PbAudio: {
                    '$': {"1":["id","string",""],"2":["size","[uint32",null],"3":["duration","[uint32",null],"5":["mimeType","string",""],"6":["fileName","string",""],"7":["performer","string",""],"8":["title","string",""],"9":["thumbnailSizes","<default.PTP.Common.PbSizes",null]}
                },
                PbBotInfo: {
                    '$': {"1":["botId","string",""],"2":["description","string",""],"4":["menuButton","default.PTP.Common.PbMenuButton",null],"5":["commands","<default.PTP.Common.PbCommands",null],"6":["photo","default.PTP.Common.PbPhoto",null],"7":["aiBot","default.PTP.Common.PbAiBot",null]}
                },
                PbCatBot: {
                    '$': {"1":["cat","string",""],"2":["userId","string",""],"3":["firstName","string",""],"4":["avatarHash","string",""],"5":["bio","string",""],"6":["init_system_content","string",""],"7":["welcome","string",""],"8":["outputText","string",""],"9":["template","string",""],"10":["templateSubmit","string",""],"11":["time","uint64",{"low":0,"high":0,"unsigned":true}]}
                },
                PbChat: {
                    '$': {"1":["type","string",""],"2":["id","string",""],"3":["title","string",""],"4":["usernames","<default.PTP.Common.PbUsernames",null],"5":["isMuted","bool",false],"6":["isMin","bool",false],"7":["hasPrivateLink","bool",false],"8":["isSignaturesShown","bool",false],"9":["accessHash","string",""],"10":["isVerified","bool",false],"11":["isJoinToSend","bool",false],"12":["isJoinRequest","bool",false],"13":["isForum","bool",false],"14":["isListed","bool",false],"15":["settings","default.PTP.Common.PbSettings",null],"16":["lastMessage","default.PTP.Common.PbMsg",null]}
                },
                PbChatFolder: {
                    '$': {"1":["id","uint32",0],"2":["title","string",""],"3":["channels","bool",false],"4":["pinnedChatIds","<string",null],"5":["includedChatIds","<string",null],"6":["excludedChatIds","<string",null]}
                },
                PbChatGpBotConfig: {
                    '$': {"1":["init_system_content","string",""],"2":["api_key","string",""],"3":["max_history_length","uint32",0],"4":["modelConfig","default.PTP.Common.PbChatGptModelConfig",null],"5":["welcome","string",""],"6":["template","string",""],"7":["outputText","string",""],"8":["templateSubmit","string",""]}
                },
                PbChatGptModelConfig: {
                    '$': {"1":["model","string",""],"2":["temperature","uint32",0],"3":["max_tokens","uint32",0],"4":["presence_penalty","uint32",0]}
                },
                PbCommands: {
                    '$': {"1":["botId","string",""],"2":["command","string",""],"3":["description","string",""]}
                },
                PbContent: {
                    '$': {"1":["text","default.PTP.Common.PbText",null],"2":["photo","default.PTP.Common.PbPhoto",null],"3":["voice","default.PTP.Common.PbVoice",null],"4":["action","default.PTP.Common.PbAction",null],"5":["document","default.PTP.Common.PbDocument",null],"6":["audio","default.PTP.Common.PbAudio",null]}
                },
                PbDimensions: {
                    '$': {"1":["width","uint32",0],"2":["height","uint32",0]}
                },
                PbDocument: {
                    '$': {"1":["id","string",""],"2":["fileName","string",""],"3":["size","[uint32",null],"4":["timestamp","uint32",0],"5":["duration","[uint32",null],"6":["mimeType","string",""],"7":["performer","string",""],"8":["previewBlobUrl","string",""],"9":["mediaType","string",""],"10":["mediaSize","default.PTP.Common.PbSizes",null],"11":["thumbnail","default.PTP.Common.PbThumbnail",null]}
                },
                PbFullInfo: {
                    '$': {"1":["bio","string",""],"2":["commonChatsCount","uint32",0],"3":["isBlocked","bool",false],"4":["noVoiceMessages","bool",false],"5":["botInfo","default.PTP.Common.PbBotInfo",null],"6":["pinnedMessageId","uint32",0]}
                },
                PbMenuButton: {
                    '$': {"1":["type","string",""],"2":["text","string",""],"3":["url","string",""]}
                },
                PbMessageEntity: {
                    '$': {"1":["type","string",""],"2":["offset","uint32",0],"3":["length","uint32",0],"4":["documentId","string",""],"5":["userId","string",""],"6":["url","string",""],"7":["language","string",""],"8":["cipher","string",""],"9":["hint","string",""]}
                },
                PbMsg: {
                    '$': {"1":["id","uint32",0],"2":["chatId","string",""],"3":["content","default.PTP.Common.PbContent",null],"4":["date","uint32",0],"5":["isOutgoing","bool",false],"6":["senderId","string",""],"7":["isForwardingAllowed","bool",false],"8":["previousLocalId","double",0],"9":["views","uint32",0],"10":["repliesThreadInfo","default.PTP.Common.PbRepliesThreadInfo",null],"11":["reactions","default.PTP.Common.PbReactions",null],"12":["replyToMessageId","uint32",0],"13":["replyToUserId","string",""]}
                },
                PbPhoto: {
                    '$': {"1":["id","string",""],"2":["thumbnail","default.PTP.Common.PbThumbnail",null],"3":["sizes","<default.PTP.Common.PbSizes",null],"4":["isSpoiler","bool",false]}
                },
                PbQrCode: {
                    '$': {"1":["type","uint32",1],"2":["data","bytes",[]]}
                },
                PbReaction: {
                    '$': {"2":["emoticon","string",""]}
                },
                PbReactionCount: {
                    '$': {"1":["chosenOrder","uint32",0],"2":["count","uint32",0],"3":["reaction","default.PTP.Common.PbReaction",null]}
                },
                PbReactions: {
                    '$': {"1":["canSeeList","bool",false],"2":["results","<default.PTP.Common.PbReactionCount",null]}
                },
                PbRepliesThreadInfo: {
                    '$': {"1":["isComments","bool",false],"3":["threadId","uint32",0],"4":["chatId","string",""],"5":["originChannelId","string",""],"6":["messagesCount","uint32",0],"7":["lastMessageId","uint32",0],"8":["recentReplierIds","<string",null]}
                },
                PbSettings: {
                    '$': {"1":["isAutoArchived","bool",false],"2":["canReportSpam","bool",false],"3":["canAddContact","bool",false],"4":["canBlockContact","bool",false]}
                },
                PbSizes: {
                    '$': {"1":["width","uint32",0],"2":["height","uint32",0],"3":["type","string",""]}
                },
                PbText: {
                    '$': {"1":["text","string",""],"2":["entities","<default.PTP.Common.PbMessageEntity",null]}
                },
                PbThumbnail: {
                    '$': {"1":["width","uint32",0],"2":["height","uint32",0],"3":["dataUri","string",""]}
                },
                PbUser: {
                    '$': {"1":["id","string",""],"2":["firstName","string",""],"3":["usernames","<default.PTP.Common.PbUsernames",null],"4":["isMin","bool",false],"5":["isPremium","bool",false],"6":["type","string",""],"7":["hasVideoAvatar","bool",false],"8":["canBeInvitedToGroup","bool",false],"9":["phoneNumber","string",""],"10":["noStatus","bool",false],"11":["accessHash","string",""],"12":["fullInfo","default.PTP.Common.PbFullInfo",null],"13":["lastName","string",""],"14":["isSelf","bool",false],"15":["avatarHash","string",""],"16":["photos","<default.PTP.Common.PbPhoto",null],"17":["updatedAt","uint32",0]}
                },
                PbUsernames: {
                    '$': {"1":["username","string",""],"2":["isActive","bool",false],"3":["isEditable","bool",false]}
                },
                PbVoice: {
                    '$': {"1":["id","string",""],"2":["waveform","[uint32",null],"3":["duration","uint32",0]}
                },
                QrCodeType: {
                    '@': {"QrCodeType_MNEMONIC":1}
                },
                UserMessageStoreData: {
                    '$': {"1":["chatId","string",""],"2":["messageIds","[uint64",null],"3":["messageIdsDeleted","[uint64",null],"4":["time","uint64",{"low":0,"high":0,"unsigned":true}]}
                },
                UserStoreData: {
                    '$': {"1":["chatIds","<string",null],"2":["chatIdsDeleted","<string",null],"3":["chatFolders","string",""],"7":["time","uint64",{"low":0,"high":0,"unsigned":true}],"8":["myBots","<string",null],"9":["myGroups","<string",null]}
                },
                UserStoreRow: {
                    '$': {"1":["buf","bytes",[]],"2":["userId","string",""],"3":["time","uint32",0],"4":["user","default.PTP.Common.PbUser",null]}
                }
            },
            File: {
                DownloadReq: {
                    '$': {"1":["id","string",""],"2":["part","uint32",0]}
                },
                DownloadRes: {
                    '$': {"1":["file","default.PTP.Common.FileInfo",null],"100":["err","uint32",0]}
                },
                UploadReq: {
                    '$': {"1":["file","default.PTP.Common.FileInfo",null]}
                },
                UploadRes: {
                    '$': {"100":["err","uint32",0]}
                }
            },
            Msg: {
                CallbackButtonReq: {
                    '$': {"1":["chatId","string",""],"2":["data","string",""]}
                },
                CallbackButtonRes: {
                    '$': {"1":["text","string",""],"2":["inlineButtons","string",""],"3":["chatId","string",""],"100":["err","uint32",0]}
                },
                DownloadMsgReq: {
                    '$': {"1":["chatId","string",""],"2":["msgIds","[uint32",null]}
                },
                DownloadMsgRes: {
                    '$': {"1":["chatId","string",""],"2":["msgList","<default.PTP.Common.PbMsg",null]}
                },
                GenMsgIdReq: {
                    '$': {"1":["isLocal","bool",false]}
                },
                GenMsgIdRes: {
                    '$': {"1":["messageId","uint64",{"low":0,"high":0,"unsigned":true}],"100":["err","uint32",0]}
                },
                MsgListReq: {
                    '$': {"1":["chatId","string",""],"2":["msgIds","[uint32",null]}
                },
                MsgListRes: {
                    '$': {"1":["chatId","string",""],"2":["msgList","<default.PTP.Common.MsgRow",null]}
                },
                RemoveMessagesReq: {
                    '$': {"1":["messageIds","[uint32",null],"2":["chatId","string",""]}
                },
                RemoveMessagesRes: {
                    '$': {"100":["err","uint32",0]}
                },
                SendBotMsgReq: {
                    '$': {"1":["chatId","string",""],"2":["botApi","string",""],"3":["text","string",""],"4":["chatGpt","string",""],"5":["msgId","uint32",0],"6":["msgDate","uint32",0],"7":["msgAskId","uint32",0],"8":["msgAskDate","uint32",0]}
                },
                SendBotMsgRes: {
                    '$': {"1":["reply","string",""],"2":["chatId","string",""],"3":["msgId","uint32",0],"4":["streamStatus","uint32",0],"5":["message","default.PTP.Common.PbMsg",null]}
                },
                SendMsgRes: {
                    '$': {"1":["replyText","string",""],"2":["chatId","string",""],"3":["msgId","uint32",0],"4":["senderId","string",""],"6":["date","uint32",0],"7":["inlineButtons","string",""],"8":["replyToMsgId","uint64",{"low":0,"high":0,"unsigned":true}]}
                },
                SendTextMsgReq: {
                    '$': {"7":["msg","bytes",[]]}
                },
                UpdateCmdReq: {
                    '$': {"2":["chatId","string",""]}
                },
                UpdateCmdRes: {
                    '$': {"1":["commands","<default.PTP.Common.PbCommands",null],"2":["chatId","string",""],"3":["startTips","string",""]}
                },
                UploadMsgReq: {
                    '$': {"1":["messages","<bytes",null],"2":["chatId","string",""]}
                },
                UploadMsgRes: {
                    '$': {"1":["userMessageStoreData","default.PTP.Common.UserMessageStoreData",null],"100":["err","uint32",0]}
                }
            },
            Other: {
                OtherNotify: {
                    '$': {"100":["err","uint32",0]}
                },
                StopChatStreamReq: {
                    '$': {"1":["chatId","uint32",0],"2":["msgId","uint32",0]}
                }
            },
            Sync: {
                SyncReq: {
                    '$': {"2":["userStoreData","default.PTP.Common.UserStoreData",null]}
                },
                SyncRes: {
                    '$': {"1":["userStoreData","default.PTP.Common.UserStoreData",null],"100":["err","uint32",0]}
                },
                TopCatsReq: {
                    '$': {"1":["time","uint64",{"low":0,"high":0,"unsigned":true}]}
                },
                TopCatsRes: {
                    '$': {"1":["payload","string",""],"100":["err","uint32",0]}
                }
            },
            User: {
                CreateUserReq: {
                    '$': {"1":["username","string",""]}
                },
                CreateUserRes: {
                    '$': {}
                },
                DownloadUserReq: {
                    '$': {"2":["userId","string",""],"3":["updatedAt","uint32",0]}
                },
                DownloadUserRes: {
                    '$': {"2":["userBuf","bytes",[]],"100":["err","uint32",0]}
                },
                FetchBotSettingReq: {
                    '$': {"1":["key","string",""]}
                },
                FetchBotSettingRes: {
                    '$': {"1":["key","string",""],"2":["value","string",""]}
                },
                GenUserIdReq: {
                    '$': {"1":["username","string",""]}
                },
                GenUserIdRes: {
                    '$': {"1":["userId","uint32",0],"100":["err","uint32",0]}
                },
                SaveBotSettingReq: {
                    '$': {"1":["key","string",""],"2":["value","string",""]}
                },
                SaveBotSettingRes: {
                    '$': {"100":["err","uint32",0]}
                },
                ShareBotReq: {
                    '$': {"1":["catTitle","string",""],"2":["catBot","default.PTP.Common.PbCatBot",null]}
                },
                ShareBotRes: {
                    '$': {"100":["err","uint32",0]}
                },
                ShareBotStopReq: {
                    '$': {"1":["userId","string",""]}
                },
                ShareBotStopRes: {
                    '$': {"100":["err","uint32",0]}
                },
                UploadUserReq: {
                    '$': {"2":["userBuf","bytes",[]]}
                },
                UploadUserRes: {
                    '$': {"100":["err","uint32",0]}
                }
            }
        }
    }
}, '', $root, false);

// exposing 'default' to global/window
protobuf.util.global['default'] = $root['default'];

//module.exports = protobuf.util.global['default']

export default protobuf.util.global['default'];
