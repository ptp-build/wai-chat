(()=>{var n,e,t={10289:(n,e,t)=>{"use strict";var r=t(35802);let a;try{a=localStorage.getItem("adr"),a||(a="0")}catch(n){a="0"}location.href.startsWith("https://");const o=("undefined"!=typeof window&&window.innerHeight,Math.round(425),new Set(["newMessage","newScheduledMessage","deleteMessages","deleteScheduledMessages","deleteHistory"]),new Set(["image/png","image/jpeg","image/gif"])),i=new Set(["video/mp4"]),s=(new Set(["audio/mp3","audio/ogg","audio/wav","audio/mpeg","audio/flac","audio/aac","audio/m4a","audio/mp4","audio/x-m4a"]),new Set([...o,...i]),new Set(["t.me","web.t.me","k.t.me","z.t.me"]),new Set(["AU","BD","CA","CO","EG","HN","IE","IN","JO","MX","MY","NI","NZ","PH","PK","SA","SV","US"]),new Map);let u;t(37373);const d=new Promise((n=>{Module.onRuntimeInitialized=()=>{u={init:Module.cwrap("lottie_init","",[]),destroy:Module.cwrap("lottie_destroy","",["number"]),resize:Module.cwrap("lottie_resize","",["number","number","number"]),buffer:Module.cwrap("lottie_buffer","number",["number"]),render:Module.cwrap("lottie_render","",["number","number"]),loadFromData:Module.cwrap("lottie_load_from_data","number",["number","number"])},n()}})),l=60,f=30,c=new Map;async function p(n){const e=await fetch(n),t=e.headers.get("Content-Type");if(t?.startsWith("text/"))return e.text();const a=await e.arrayBuffer();return(0,r.inflate)(a,{to:"string"})}function m(n,e,t){const r=JSON.parse(n),a=e?f:l,o=r.fr||a,i=o%a==0?o/a:1;return{reduceFactor:i,msPerFrame:1e3/(o/i),reducedFramesCount:Math.ceil(t/i)}}!function(n,e){function t(n,t){n.channel=e,t?postMessage(n,t):postMessage(n)}!function(n){self.onerror=e=>{console.error(e),n({type:"unhandledError",error:{message:e.error.message||"Uncaught exception in worker"}})},self.addEventListener("unhandledrejection",(e=>{console.error(e),n({type:"unhandledError",error:{message:e.reason.message||"Uncaught rejection in worker"}})}))}(t),onmessage=r=>{r.data?.channel===e&&async function(n,e,t,r){switch(r||(r=n=>{t({type:"update",update:n})}),e.type){case"init":{const{args:t}=e,a="function"==typeof n?n("init",r,...t):n.init?.(r,...t);await a;break}case"callMethod":{const{messageId:r,name:a,args:o,withCallback:i}=e;try{if(r&&i){const n=(...n)=>{const e=n[n.length-1];var a;t({type:"methodCallback",messageId:r,callbackArgs:n},(a=e)instanceof ArrayBuffer||a instanceof ImageBitmap?[e]:void 0)};s.set(r,n),o.push(n)}const e="function"==typeof n?await n(a,...o):await n[a](...o),{arrayBuffer:u}="object"==typeof e&&"arrayBuffer"in e&&e||{};r&&t({type:"methodResponse",messageId:r,response:e},u?[u]:void 0)}catch(n){r&&t({type:"methodResponse",messageId:r,error:{message:n.message}})}r&&s.delete(r);break}case"cancelProgress":{const n=s.get(e.messageId);n&&(n.isCanceled=!0);break}}}(n,r.data,t)}}({init:async function(n,e,t,r,a,o){u||await d;const i=await p(e),s=allocate(intArrayFromString(i),"i8",0),l=u.init(),f=u.loadFromData(l,s);u.resize(l,t,t);const h=new ImageData(t,t),{reduceFactor:S,msPerFrame:g,reducedFramesCount:_}=m(i,r,f);c.set(n,{imgSize:t,reduceFactor:S,handle:l,imageData:h,customColor:a}),o(S,g,_)},changeData:async function(n,e,t,r){u||await d;const a=await p(e),o=allocate(intArrayFromString(a),"i8",0),{handle:i}=c.get(n),s=u.loadFromData(i,o),{reduceFactor:l,msPerFrame:f,reducedFramesCount:h}=m(a,t,s);r(l,f,h)},renderFrames:async function(n,e,t){u||await d;const{imgSize:r,reduceFactor:a,handle:o,imageData:i,customColor:s}=c.get(n),l=e*a;u.render(o,l);const f=u.buffer(o),p=Module.HEAPU8.subarray(f,f+r*r*4);if(s){const n=new Uint8ClampedArray(p);!function(n,e){for(let t=0;t<n.length;t+=4)n[t]=e[0],n[t+1]=e[1],n[t+2]=e[2]}(n,s),i.data.set(n)}else i.data.set(p);t(e,await createImageBitmap(i))},destroy:function n(e,t=!1){try{const n=c.get(e);u.destroy(n.handle),c.delete(e)}catch(r){t||setTimeout((()=>n(e,!0)),1e3)}}})},42182:n=>{n.exports='var Module = typeof Module !== "undefined" ? Module : {};\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\nvar arguments_ = [];\nvar thisProgram = "./this.program";\nvar quit_ = function (status, toThrow) {\n  throw toThrow;\n};\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\nENVIRONMENT_IS_WEB = typeof window === "object";\nENVIRONMENT_IS_WORKER = typeof importScripts === "function";\nENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\nvar scriptDirectory = "";\nfunction locateFile(path) {\n  if (Module["locateFile"]) {\n    return Module["locateFile"](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\nvar read_, readAsync, readBinary, setWindowTitle;\nvar nodeFS;\nvar nodePath;\nif (ENVIRONMENT_IS_NODE) {\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = require("path").dirname(scriptDirectory) + "/";\n  } else {\n    scriptDirectory = __dirname + "/";\n  }\n  read_ = function shell_read(filename, binary) {\n    if (!nodeFS) nodeFS = require("fs");\n    if (!nodePath) nodePath = require("path");\n    filename = nodePath["normalize"](filename);\n    return nodeFS["readFileSync"](filename, binary ? null : "utf8");\n  };\n  readBinary = function readBinary(filename) {\n    var ret = read_(filename, true);\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n    assert(ret.buffer);\n    return ret;\n  };\n  if (process["argv"].length > 1) {\n    thisProgram = process["argv"][1].replace(/\\\\/g, "/");\n  }\n  arguments_ = process["argv"].slice(2);\n  if (typeof module !== "undefined") {\n    module["exports"] = Module;\n  }\n  process["on"]("uncaughtException", function (ex) {\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n  process["on"]("unhandledRejection", abort);\n  quit_ = function (status) {\n    process["exit"](status);\n  };\n  Module["inspect"] = function () {\n    return "[Emscripten Module object]";\n  };\n} else if (ENVIRONMENT_IS_SHELL) {\n  if (typeof read != "undefined") {\n    read_ = function shell_read(f) {\n      return read(f);\n    };\n  }\n  readBinary = function readBinary(f) {\n    var data;\n    if (typeof readbuffer === "function") {\n      return new Uint8Array(readbuffer(f));\n    }\n    data = read(f, "binary");\n    assert(typeof data === "object");\n    return data;\n  };\n  if (typeof scriptArgs != "undefined") {\n    arguments_ = scriptArgs;\n  } else if (typeof arguments != "undefined") {\n    arguments_ = arguments;\n  }\n  if (typeof quit === "function") {\n    quit_ = function (status) {\n      quit(status);\n    };\n  }\n  if (typeof print !== "undefined") {\n    if (typeof console === "undefined") console = {};\n    console.log = print;\n    console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;\n  }\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = self.location.href;\n  } else if (document.currentScript) {\n    scriptDirectory = document.currentScript.src;\n  }\n  if (scriptDirectory.indexOf("blob:") !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);\n  } else {\n    scriptDirectory = "";\n  }\n  {\n    read_ = function shell_read(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open("GET", url, false);\n      xhr.send(null);\n      return xhr.responseText;\n    };\n    if (ENVIRONMENT_IS_WORKER) {\n      readBinary = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open("GET", url, false);\n        xhr.responseType = "arraybuffer";\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n      };\n    }\n    readAsync = function readAsync(url, onload, onerror) {\n      var xhr = new XMLHttpRequest();\n      xhr.open("GET", url, true);\n      xhr.responseType = "arraybuffer";\n      xhr.onload = function xhr_onload() {\n        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n          onload(xhr.response);\n          return;\n        }\n        onerror();\n      };\n      xhr.onerror = onerror;\n      xhr.send(null);\n    };\n  }\n  setWindowTitle = function (title) {\n    document.title = title;\n  };\n} else {}\nvar out = Module["print"] || console.log.bind(console);\nvar err = Module["printErr"] || console.warn.bind(console);\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\nmoduleOverrides = null;\nif (Module["arguments"]) arguments_ = Module["arguments"];\nif (Module["thisProgram"]) thisProgram = Module["thisProgram"];\nif (Module["quit"]) quit_ = Module["quit"];\nfunction dynamicAlloc(size) {\n  var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n  var end = ret + size + 15 & -16;\n  HEAP32[DYNAMICTOP_PTR >> 2] = end;\n  return ret;\n}\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case "i1":\n    case "i8":\n      return 1;\n    case "i16":\n      return 2;\n    case "i32":\n      return 4;\n    case "i64":\n      return 8;\n    case "float":\n      return 4;\n    case "double":\n      return 8;\n    default:\n      {\n        if (type[type.length - 1] === "*") {\n          return 4;\n        } else if (type[0] === "i") {\n          var bits = Number(type.substr(1));\n          assert(bits % 8 === 0, "getNativeTypeSize invalid bits " + bits + ", type " + type);\n          return bits / 8;\n        } else {\n          return 0;\n        }\n      }\n  }\n}\nvar tempRet0 = 0;\nvar setTempRet0 = function (value) {\n  tempRet0 = value;\n};\nvar getTempRet0 = function () {\n  return tempRet0;\n};\nvar wasmBinary;\nif (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];\nvar noExitRuntime;\nif (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];\nif (typeof WebAssembly !== "object") {\n  err("no native wasm support detected");\n}\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || "i8";\n  if (type.charAt(type.length - 1) === "*") type = "i32";\n  switch (type) {\n    case "i1":\n      HEAP8[ptr >> 0] = value;\n      break;\n    case "i8":\n      HEAP8[ptr >> 0] = value;\n      break;\n    case "i16":\n      HEAP16[ptr >> 1] = value;\n      break;\n    case "i32":\n      HEAP32[ptr >> 2] = value;\n      break;\n    case "i64":\n      tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n      break;\n    case "float":\n      HEAPF32[ptr >> 2] = value;\n      break;\n    case "double":\n      HEAPF64[ptr >> 3] = value;\n      break;\n    default:\n      abort("invalid type for setValue: " + type);\n  }\n}\nvar wasmMemory;\nvar wasmTable = new WebAssembly.Table({\n  "initial": 522,\n  "maximum": 522 + 0,\n  "element": "anyfunc"\n});\nvar ABORT = false;\nvar EXITSTATUS = 0;\nfunction assert(condition, text) {\n  if (!condition) {\n    abort("Assertion failed: " + text);\n  }\n}\nfunction getCFunc(ident) {\n  var func = Module["_" + ident];\n  assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");\n  return func;\n}\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  var toC = {\n    "string": function (str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) {\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n      return ret;\n    },\n    "array": function (arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n  function convertReturnValue(ret) {\n    if (returnType === "string") return UTF8ToString(ret);\n    if (returnType === "boolean") return Boolean(ret);\n    return ret;\n  }\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\nfunction cwrap(ident, returnType, argTypes, opts) {\n  argTypes = argTypes || [];\n  var numericArgs = argTypes.every(function (type) {\n    return type === "number";\n  });\n  var numericRet = returnType !== "string";\n  if (numericRet && numericArgs && !opts) {\n    return getCFunc(ident);\n  }\n  return function () {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  };\n}\nvar ALLOC_NONE = 3;\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === "number") {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n  var singleType = typeof types === "string" ? types : null;\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[ptr >> 2] = 0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[ptr++ >> 0] = 0;\n    }\n    return ret;\n  }\n  if (singleType === "i8") {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(slab, ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n  var i = 0,\n    type,\n    typeSize,\n    previousType;\n  while (i < size) {\n    var curr = slab[i];\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n    if (type == "i64") type = "i32";\n    setValue(ret + i, curr, type);\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n  return ret;\n}\nvar UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n  } else {\n    var str = "";\n    while (idx < endPtr) {\n      var u0 = heap[idx++];\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n      var u1 = heap[idx++] & 63;\n      if ((u0 & 224) == 192) {\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\n        continue;\n      }\n      var u2 = heap[idx++] & 63;\n      if ((u0 & 240) == 224) {\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n      } else {\n        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 65536;\n        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n      }\n    }\n  }\n  return str;\n}\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";\n}\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) return 0;\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1;\n  for (var i = 0; i < str.length; ++i) {\n    var u = str.charCodeAt(i);\n    if (u >= 55296 && u <= 57343) {\n      var u1 = str.charCodeAt(++i);\n      u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n    }\n    if (u <= 127) {\n      if (outIdx >= endIdx) break;\n      heap[outIdx++] = u;\n    } else if (u <= 2047) {\n      if (outIdx + 1 >= endIdx) break;\n      heap[outIdx++] = 192 | u >> 6;\n      heap[outIdx++] = 128 | u & 63;\n    } else if (u <= 65535) {\n      if (outIdx + 2 >= endIdx) break;\n      heap[outIdx++] = 224 | u >> 12;\n      heap[outIdx++] = 128 | u >> 6 & 63;\n      heap[outIdx++] = 128 | u & 63;\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      heap[outIdx++] = 240 | u >> 18;\n      heap[outIdx++] = 128 | u >> 12 & 63;\n      heap[outIdx++] = 128 | u >> 6 & 63;\n      heap[outIdx++] = 128 | u & 63;\n    }\n  }\n  heap[outIdx] = 0;\n  return outIdx - startIdx;\n}\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n}\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    var u = str.charCodeAt(i);\n    if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n    if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;\n  }\n  return len;\n}\nfunction writeArrayToMemory(array, buffer) {\n  HEAP8.set(array, buffer);\n}\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n  }\n  if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n}\nvar WASM_PAGE_SIZE = 65536;\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - x % multiple;\n  }\n  return x;\n}\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module["HEAP8"] = HEAP8 = new Int8Array(buf);\n  Module["HEAP16"] = HEAP16 = new Int16Array(buf);\n  Module["HEAP32"] = HEAP32 = new Int32Array(buf);\n  Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);\n  Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);\n  Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);\n  Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);\n  Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);\n}\nvar DYNAMIC_BASE = 5275232,\n  DYNAMICTOP_PTR = 32192;\nvar INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;\nif (Module["wasmMemory"]) {\n  wasmMemory = Module["wasmMemory"];\n} else {\n  wasmMemory = new WebAssembly.Memory({\n    "initial": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,\n    "maximum": 2147483648 / WASM_PAGE_SIZE\n  });\n}\nif (wasmMemory) {\n  buffer = wasmMemory.buffer;\n}\nINITIAL_INITIAL_MEMORY = buffer.byteLength;\nupdateGlobalBufferAndViews(buffer);\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\nfunction callRuntimeCallbacks(callbacks) {\n  while (callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == "function") {\n      callback(Module);\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === "number") {\n      if (callback.arg === undefined) {\n        Module["dynCall_v"](func);\n      } else {\n        Module["dynCall_vi"](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\nvar __ATPRERUN__ = [];\nvar __ATINIT__ = [];\nvar __ATMAIN__ = [];\nvar __ATPOSTRUN__ = [];\nvar runtimeInitialized = false;\nfunction preRun() {\n  if (Module["preRun"]) {\n    if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];\n    while (Module["preRun"].length) {\n      addOnPreRun(Module["preRun"].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\nfunction initRuntime() {\n  runtimeInitialized = true;\n  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();\n  TTY.init();\n  callRuntimeCallbacks(__ATINIT__);\n}\nfunction preMain() {\n  FS.ignorePermissions = false;\n  callRuntimeCallbacks(__ATMAIN__);\n}\nfunction postRun() {\n  if (Module["postRun"]) {\n    if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];\n    while (Module["postRun"].length) {\n      addOnPostRun(Module["postRun"].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\nvar Math_abs = Math.abs;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_min = Math.min;\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null;\nfunction getUniqueRunDependency(id) {\n  return id;\n}\nfunction addRunDependency(id) {\n  runDependencies++;\n  if (Module["monitorRunDependencies"]) {\n    Module["monitorRunDependencies"](runDependencies);\n  }\n}\nfunction removeRunDependency(id) {\n  runDependencies--;\n  if (Module["monitorRunDependencies"]) {\n    Module["monitorRunDependencies"](runDependencies);\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback();\n    }\n  }\n}\nModule["preloadedImages"] = {};\nModule["preloadedAudios"] = {};\nfunction abort(what) {\n  if (Module["onAbort"]) {\n    Module["onAbort"](what);\n  }\n  what += "";\n  out(what);\n  err(what);\n  ABORT = true;\n  EXITSTATUS = 1;\n  what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";\n  throw new WebAssembly.RuntimeError(what);\n}\nfunction hasPrefix(str, prefix) {\n  return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;\n}\nvar dataURIPrefix = "data:application/octet-stream;base64,";\nfunction isDataURI(filename) {\n  return hasPrefix(filename, dataURIPrefix);\n}\nvar fileURIPrefix = "file://";\nfunction isFileURI(filename) {\n  return hasPrefix(filename, fileURIPrefix);\n}\nvar wasmBinaryFile = "rlottie-wasm.wasm";\nif (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n}\nfunction getBinary() {\n  try {\n    if (wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n    if (readBinary) {\n      return readBinary(wasmBinaryFile);\n    } else {\n      throw "both async and sync fetching of the wasm failed";\n    }\n  } catch (err) {\n    abort(err);\n  }\n}\nfunction getBinaryPromise() {\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {\n    return fetch(wasmBinaryFile, {\n      credentials: "same-origin"\n    }).then(function (response) {\n      if (!response["ok"]) {\n        throw "failed to load wasm binary file at \'" + wasmBinaryFile + "\'";\n      }\n      return response["arrayBuffer"]();\n    }).catch(function () {\n      return getBinary();\n    });\n  }\n  return new Promise(function (resolve, reject) {\n    resolve(getBinary());\n  });\n}\nfunction createWasm() {\n  var info = {\n    "a": asmLibraryArg\n  };\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n    Module["asm"] = exports;\n    removeRunDependency("wasm-instantiate");\n  }\n  addRunDependency("wasm-instantiate");\n  function receiveInstantiatedSource(output) {\n    receiveInstance(output["instance"]);\n  }\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function (binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(receiver, function (reason) {\n      err("failed to asynchronously prepare wasm: " + reason);\n      abort(reason);\n    });\n  }\n  function instantiateAsync() {\n    if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {\n      fetch(wasmBinaryFile, {\n        credentials: "same-origin"\n      }).then(function (response) {\n        var result = WebAssembly.instantiateStreaming(response, info);\n        return result.then(receiveInstantiatedSource, function (reason) {\n          err("wasm streaming compile failed: " + reason);\n          err("falling back to ArrayBuffer instantiation");\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n  }\n  if (Module["instantiateWasm"]) {\n    try {\n      var exports = Module["instantiateWasm"](info, receiveInstance);\n      return exports;\n    } catch (e) {\n      err("Module.instantiateWasm callback failed with error: " + e);\n      return false;\n    }\n  }\n  instantiateAsync();\n  return {};\n}\nvar tempDouble;\nvar tempI64;\n__ATINIT__.push({\n  func: function () {\n    ___wasm_call_ctors();\n  }\n});\nfunction demangle(func) {\n  return func;\n}\nfunction demangleAll(text) {\n  var regex = /\\b_Z[\\w\\d_]+/g;\n  return text.replace(regex, function (x) {\n    var y = demangle(x);\n    return x === y ? x : y + " [" + x + "]";\n  });\n}\nfunction jsStackTrace() {\n  var err = new Error();\n  if (!err.stack) {\n    try {\n      throw new Error();\n    } catch (e) {\n      err = e;\n    }\n    if (!err.stack) {\n      return "(no stack trace available)";\n    }\n  }\n  return err.stack.toString();\n}\nfunction stackTrace() {\n  var js = jsStackTrace();\n  if (Module["extraStackTrace"]) js += "\\n" + Module["extraStackTrace"]();\n  return demangleAll(js);\n}\nfunction __ZN7VRegionC1ERK5VRect() {\n  err("missing function: _ZN7VRegionC1ERK5VRect");\n  abort(-1);\n}\nfunction __ZN7VRegionD1Ev() {\n  err("missing function: _ZN7VRegionD1Ev");\n  abort(-1);\n}\nfunction __ZN7VRegionpLERK5VRect() {\n  err("missing function: _ZN7VRegionpLERK5VRect");\n  abort(-1);\n}\nfunction __ZNK7VRegion12boundingRectEv() {\n  err("missing function: _ZNK7VRegion12boundingRectEv");\n  abort(-1);\n}\nfunction ___assert_fail(condition, filename, line, func) {\n  abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);\n}\nfunction setErrNo(value) {\n  HEAP32[___errno_location() >> 2] = value;\n  return value;\n}\nfunction ___map_file(pathname, size) {\n  setErrNo(63);\n  return -1;\n}\nvar PATH = {\n  splitPath: function (filename) {\n    var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n    return splitPathRe.exec(filename).slice(1);\n  },\n  normalizeArray: function (parts, allowAboveRoot) {\n    var up = 0;\n    for (var i = parts.length - 1; i >= 0; i--) {\n      var last = parts[i];\n      if (last === ".") {\n        parts.splice(i, 1);\n      } else if (last === "..") {\n        parts.splice(i, 1);\n        up++;\n      } else if (up) {\n        parts.splice(i, 1);\n        up--;\n      }\n    }\n    if (allowAboveRoot) {\n      for (; up; up--) {\n        parts.unshift("..");\n      }\n    }\n    return parts;\n  },\n  normalize: function (path) {\n    var isAbsolute = path.charAt(0) === "/",\n      trailingSlash = path.substr(-1) === "/";\n    path = PATH.normalizeArray(path.split("/").filter(function (p) {\n      return !!p;\n    }), !isAbsolute).join("/");\n    if (!path && !isAbsolute) {\n      path = ".";\n    }\n    if (path && trailingSlash) {\n      path += "/";\n    }\n    return (isAbsolute ? "/" : "") + path;\n  },\n  dirname: function (path) {\n    var result = PATH.splitPath(path),\n      root = result[0],\n      dir = result[1];\n    if (!root && !dir) {\n      return ".";\n    }\n    if (dir) {\n      dir = dir.substr(0, dir.length - 1);\n    }\n    return root + dir;\n  },\n  basename: function (path) {\n    if (path === "/") return "/";\n    var lastSlash = path.lastIndexOf("/");\n    if (lastSlash === -1) return path;\n    return path.substr(lastSlash + 1);\n  },\n  extname: function (path) {\n    return PATH.splitPath(path)[3];\n  },\n  join: function () {\n    var paths = Array.prototype.slice.call(arguments, 0);\n    return PATH.normalize(paths.join("/"));\n  },\n  join2: function (l, r) {\n    return PATH.normalize(l + "/" + r);\n  }\n};\nvar PATH_FS = {\n  resolve: function () {\n    var resolvedPath = "",\n      resolvedAbsolute = false;\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = i >= 0 ? arguments[i] : FS.cwd();\n      if (typeof path !== "string") {\n        throw new TypeError("Arguments to path.resolve must be strings");\n      } else if (!path) {\n        return "";\n      }\n      resolvedPath = path + "/" + resolvedPath;\n      resolvedAbsolute = path.charAt(0) === "/";\n    }\n    resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function (p) {\n      return !!p;\n    }), !resolvedAbsolute).join("/");\n    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";\n  },\n  relative: function (from, to) {\n    from = PATH_FS.resolve(from).substr(1);\n    to = PATH_FS.resolve(to).substr(1);\n    function trim(arr) {\n      var start = 0;\n      for (; start < arr.length; start++) {\n        if (arr[start] !== "") break;\n      }\n      var end = arr.length - 1;\n      for (; end >= 0; end--) {\n        if (arr[end] !== "") break;\n      }\n      if (start > end) return [];\n      return arr.slice(start, end - start + 1);\n    }\n    var fromParts = trim(from.split("/"));\n    var toParts = trim(to.split("/"));\n    var length = Math.min(fromParts.length, toParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n      if (fromParts[i] !== toParts[i]) {\n        samePartsLength = i;\n        break;\n      }\n    }\n    var outputParts = [];\n    for (var i = samePartsLength; i < fromParts.length; i++) {\n      outputParts.push("..");\n    }\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n    return outputParts.join("/");\n  }\n};\nvar TTY = {\n  ttys: [],\n  init: function () {},\n  shutdown: function () {},\n  register: function (dev, ops) {\n    TTY.ttys[dev] = {\n      input: [],\n      output: [],\n      ops: ops\n    };\n    FS.registerDevice(dev, TTY.stream_ops);\n  },\n  stream_ops: {\n    open: function (stream) {\n      var tty = TTY.ttys[stream.node.rdev];\n      if (!tty) {\n        throw new FS.ErrnoError(43);\n      }\n      stream.tty = tty;\n      stream.seekable = false;\n    },\n    close: function (stream) {\n      stream.tty.ops.flush(stream.tty);\n    },\n    flush: function (stream) {\n      stream.tty.ops.flush(stream.tty);\n    },\n    read: function (stream, buffer, offset, length, pos) {\n      if (!stream.tty || !stream.tty.ops.get_char) {\n        throw new FS.ErrnoError(60);\n      }\n      var bytesRead = 0;\n      for (var i = 0; i < length; i++) {\n        var result;\n        try {\n          result = stream.tty.ops.get_char(stream.tty);\n        } catch (e) {\n          throw new FS.ErrnoError(29);\n        }\n        if (result === undefined && bytesRead === 0) {\n          throw new FS.ErrnoError(6);\n        }\n        if (result === null || result === undefined) break;\n        bytesRead++;\n        buffer[offset + i] = result;\n      }\n      if (bytesRead) {\n        stream.node.timestamp = Date.now();\n      }\n      return bytesRead;\n    },\n    write: function (stream, buffer, offset, length, pos) {\n      if (!stream.tty || !stream.tty.ops.put_char) {\n        throw new FS.ErrnoError(60);\n      }\n      try {\n        for (var i = 0; i < length; i++) {\n          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n        }\n      } catch (e) {\n        throw new FS.ErrnoError(29);\n      }\n      if (length) {\n        stream.node.timestamp = Date.now();\n      }\n      return i;\n    }\n  },\n  default_tty_ops: {\n    get_char: function (tty) {\n      if (!tty.input.length) {\n        var result = null;\n        if (ENVIRONMENT_IS_NODE) {\n          var BUFSIZE = 256;\n          var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);\n          var bytesRead = 0;\n          try {\n            bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);\n          } catch (e) {\n            if (e.toString().indexOf("EOF") != -1) bytesRead = 0;else throw e;\n          }\n          if (bytesRead > 0) {\n            result = buf.slice(0, bytesRead).toString("utf-8");\n          } else {\n            result = null;\n          }\n        } else if (typeof window != "undefined" && typeof window.prompt == "function") {\n          result = window.prompt("Input: ");\n          if (result !== null) {\n            result += "\\n";\n          }\n        } else if (typeof readline == "function") {\n          result = readline();\n          if (result !== null) {\n            result += "\\n";\n          }\n        }\n        if (!result) {\n          return null;\n        }\n        tty.input = intArrayFromString(result, true);\n      }\n      return tty.input.shift();\n    },\n    put_char: function (tty, val) {\n      if (val === null || val === 10) {\n        out(UTF8ArrayToString(tty.output, 0));\n        tty.output = [];\n      } else {\n        if (val != 0) tty.output.push(val);\n      }\n    },\n    flush: function (tty) {\n      if (tty.output && tty.output.length > 0) {\n        out(UTF8ArrayToString(tty.output, 0));\n        tty.output = [];\n      }\n    }\n  },\n  default_tty1_ops: {\n    put_char: function (tty, val) {\n      if (val === null || val === 10) {\n        err(UTF8ArrayToString(tty.output, 0));\n        tty.output = [];\n      } else {\n        if (val != 0) tty.output.push(val);\n      }\n    },\n    flush: function (tty) {\n      if (tty.output && tty.output.length > 0) {\n        err(UTF8ArrayToString(tty.output, 0));\n        tty.output = [];\n      }\n    }\n  }\n};\nvar MEMFS = {\n  ops_table: null,\n  mount: function (mount) {\n    return MEMFS.createNode(null, "/", 16384 | 511, 0);\n  },\n  createNode: function (parent, name, mode, dev) {\n    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n      throw new FS.ErrnoError(63);\n    }\n    if (!MEMFS.ops_table) {\n      MEMFS.ops_table = {\n        dir: {\n          node: {\n            getattr: MEMFS.node_ops.getattr,\n            setattr: MEMFS.node_ops.setattr,\n            lookup: MEMFS.node_ops.lookup,\n            mknod: MEMFS.node_ops.mknod,\n            rename: MEMFS.node_ops.rename,\n            unlink: MEMFS.node_ops.unlink,\n            rmdir: MEMFS.node_ops.rmdir,\n            readdir: MEMFS.node_ops.readdir,\n            symlink: MEMFS.node_ops.symlink\n          },\n          stream: {\n            llseek: MEMFS.stream_ops.llseek\n          }\n        },\n        file: {\n          node: {\n            getattr: MEMFS.node_ops.getattr,\n            setattr: MEMFS.node_ops.setattr\n          },\n          stream: {\n            llseek: MEMFS.stream_ops.llseek,\n            read: MEMFS.stream_ops.read,\n            write: MEMFS.stream_ops.write,\n            allocate: MEMFS.stream_ops.allocate,\n            mmap: MEMFS.stream_ops.mmap,\n            msync: MEMFS.stream_ops.msync\n          }\n        },\n        link: {\n          node: {\n            getattr: MEMFS.node_ops.getattr,\n            setattr: MEMFS.node_ops.setattr,\n            readlink: MEMFS.node_ops.readlink\n          },\n          stream: {}\n        },\n        chrdev: {\n          node: {\n            getattr: MEMFS.node_ops.getattr,\n            setattr: MEMFS.node_ops.setattr\n          },\n          stream: FS.chrdev_stream_ops\n        }\n      };\n    }\n    var node = FS.createNode(parent, name, mode, dev);\n    if (FS.isDir(node.mode)) {\n      node.node_ops = MEMFS.ops_table.dir.node;\n      node.stream_ops = MEMFS.ops_table.dir.stream;\n      node.contents = {};\n    } else if (FS.isFile(node.mode)) {\n      node.node_ops = MEMFS.ops_table.file.node;\n      node.stream_ops = MEMFS.ops_table.file.stream;\n      node.usedBytes = 0;\n      node.contents = null;\n    } else if (FS.isLink(node.mode)) {\n      node.node_ops = MEMFS.ops_table.link.node;\n      node.stream_ops = MEMFS.ops_table.link.stream;\n    } else if (FS.isChrdev(node.mode)) {\n      node.node_ops = MEMFS.ops_table.chrdev.node;\n      node.stream_ops = MEMFS.ops_table.chrdev.stream;\n    }\n    node.timestamp = Date.now();\n    if (parent) {\n      parent.contents[name] = node;\n    }\n    return node;\n  },\n  getFileDataAsRegularArray: function (node) {\n    if (node.contents && node.contents.subarray) {\n      var arr = [];\n      for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\n      return arr;\n    }\n    return node.contents;\n  },\n  getFileDataAsTypedArray: function (node) {\n    if (!node.contents) return new Uint8Array(0);\n    if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n    return new Uint8Array(node.contents);\n  },\n  expandFileStorage: function (node, newCapacity) {\n    var prevCapacity = node.contents ? node.contents.length : 0;\n    if (prevCapacity >= newCapacity) return;\n    var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n    newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n    var oldContents = node.contents;\n    node.contents = new Uint8Array(newCapacity);\n    if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n    return;\n  },\n  resizeFileStorage: function (node, newSize) {\n    if (node.usedBytes == newSize) return;\n    if (newSize == 0) {\n      node.contents = null;\n      node.usedBytes = 0;\n      return;\n    }\n    if (!node.contents || node.contents.subarray) {\n      var oldContents = node.contents;\n      node.contents = new Uint8Array(newSize);\n      if (oldContents) {\n        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n      }\n      node.usedBytes = newSize;\n      return;\n    }\n    if (!node.contents) node.contents = [];\n    if (node.contents.length > newSize) node.contents.length = newSize;else while (node.contents.length < newSize) node.contents.push(0);\n    node.usedBytes = newSize;\n  },\n  node_ops: {\n    getattr: function (node) {\n      var attr = {};\n      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n      attr.ino = node.id;\n      attr.mode = node.mode;\n      attr.nlink = 1;\n      attr.uid = 0;\n      attr.gid = 0;\n      attr.rdev = node.rdev;\n      if (FS.isDir(node.mode)) {\n        attr.size = 4096;\n      } else if (FS.isFile(node.mode)) {\n        attr.size = node.usedBytes;\n      } else if (FS.isLink(node.mode)) {\n        attr.size = node.link.length;\n      } else {\n        attr.size = 0;\n      }\n      attr.atime = new Date(node.timestamp);\n      attr.mtime = new Date(node.timestamp);\n      attr.ctime = new Date(node.timestamp);\n      attr.blksize = 4096;\n      attr.blocks = Math.ceil(attr.size / attr.blksize);\n      return attr;\n    },\n    setattr: function (node, attr) {\n      if (attr.mode !== undefined) {\n        node.mode = attr.mode;\n      }\n      if (attr.timestamp !== undefined) {\n        node.timestamp = attr.timestamp;\n      }\n      if (attr.size !== undefined) {\n        MEMFS.resizeFileStorage(node, attr.size);\n      }\n    },\n    lookup: function (parent, name) {\n      throw FS.genericErrors[44];\n    },\n    mknod: function (parent, name, mode, dev) {\n      return MEMFS.createNode(parent, name, mode, dev);\n    },\n    rename: function (old_node, new_dir, new_name) {\n      if (FS.isDir(old_node.mode)) {\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n        if (new_node) {\n          for (var i in new_node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n        }\n      }\n      delete old_node.parent.contents[old_node.name];\n      old_node.name = new_name;\n      new_dir.contents[new_name] = old_node;\n      old_node.parent = new_dir;\n    },\n    unlink: function (parent, name) {\n      delete parent.contents[name];\n    },\n    rmdir: function (parent, name) {\n      var node = FS.lookupNode(parent, name);\n      for (var i in node.contents) {\n        throw new FS.ErrnoError(55);\n      }\n      delete parent.contents[name];\n    },\n    readdir: function (node) {\n      var entries = [".", ".."];\n      for (var key in node.contents) {\n        if (!node.contents.hasOwnProperty(key)) {\n          continue;\n        }\n        entries.push(key);\n      }\n      return entries;\n    },\n    symlink: function (parent, newname, oldpath) {\n      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n      node.link = oldpath;\n      return node;\n    },\n    readlink: function (node) {\n      if (!FS.isLink(node.mode)) {\n        throw new FS.ErrnoError(28);\n      }\n      return node.link;\n    }\n  },\n  stream_ops: {\n    read: function (stream, buffer, offset, length, position) {\n      var contents = stream.node.contents;\n      if (position >= stream.node.usedBytes) return 0;\n      var size = Math.min(stream.node.usedBytes - position, length);\n      if (size > 8 && contents.subarray) {\n        buffer.set(contents.subarray(position, position + size), offset);\n      } else {\n        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n      }\n      return size;\n    },\n    write: function (stream, buffer, offset, length, position, canOwn) {\n      if (buffer.buffer === HEAP8.buffer) {\n        canOwn = false;\n      }\n      if (!length) return 0;\n      var node = stream.node;\n      node.timestamp = Date.now();\n      if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n        if (canOwn) {\n          node.contents = buffer.subarray(offset, offset + length);\n          node.usedBytes = length;\n          return length;\n        } else if (node.usedBytes === 0 && position === 0) {\n          node.contents = buffer.slice(offset, offset + length);\n          node.usedBytes = length;\n          return length;\n        } else if (position + length <= node.usedBytes) {\n          node.contents.set(buffer.subarray(offset, offset + length), position);\n          return length;\n        }\n      }\n      MEMFS.expandFileStorage(node, position + length);\n      if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);else {\n        for (var i = 0; i < length; i++) {\n          node.contents[position + i] = buffer[offset + i];\n        }\n      }\n      node.usedBytes = Math.max(node.usedBytes, position + length);\n      return length;\n    },\n    llseek: function (stream, offset, whence) {\n      var position = offset;\n      if (whence === 1) {\n        position += stream.position;\n      } else if (whence === 2) {\n        if (FS.isFile(stream.node.mode)) {\n          position += stream.node.usedBytes;\n        }\n      }\n      if (position < 0) {\n        throw new FS.ErrnoError(28);\n      }\n      return position;\n    },\n    allocate: function (stream, offset, length) {\n      MEMFS.expandFileStorage(stream.node, offset + length);\n      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n    },\n    mmap: function (stream, buffer, offset, length, position, prot, flags) {\n      if (!FS.isFile(stream.node.mode)) {\n        throw new FS.ErrnoError(43);\n      }\n      var ptr;\n      var allocated;\n      var contents = stream.node.contents;\n      if (!(flags & 2) && contents.buffer === buffer.buffer) {\n        allocated = false;\n        ptr = contents.byteOffset;\n      } else {\n        if (position > 0 || position + length < contents.length) {\n          if (contents.subarray) {\n            contents = contents.subarray(position, position + length);\n          } else {\n            contents = Array.prototype.slice.call(contents, position, position + length);\n          }\n        }\n        allocated = true;\n        var fromHeap = buffer.buffer == HEAP8.buffer;\n        ptr = _malloc(length);\n        if (!ptr) {\n          throw new FS.ErrnoError(48);\n        }\n        (fromHeap ? HEAP8 : buffer).set(contents, ptr);\n      }\n      return {\n        ptr: ptr,\n        allocated: allocated\n      };\n    },\n    msync: function (stream, buffer, offset, length, mmapFlags) {\n      if (!FS.isFile(stream.node.mode)) {\n        throw new FS.ErrnoError(43);\n      }\n      if (mmapFlags & 2) {\n        return 0;\n      }\n      var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n      return 0;\n    }\n  }\n};\nvar FS = {\n  root: null,\n  mounts: [],\n  devices: {},\n  streams: [],\n  nextInode: 1,\n  nameTable: null,\n  currentPath: "/",\n  initialized: false,\n  ignorePermissions: true,\n  trackingDelegate: {},\n  tracking: {\n    openFlags: {\n      READ: 1,\n      WRITE: 2\n    }\n  },\n  ErrnoError: null,\n  genericErrors: {},\n  filesystems: null,\n  syncFSRequests: 0,\n  handleFSError: function (e) {\n    if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();\n    return setErrNo(e.errno);\n  },\n  lookupPath: function (path, opts) {\n    path = PATH_FS.resolve(FS.cwd(), path);\n    opts = opts || {};\n    if (!path) return {\n      path: "",\n      node: null\n    };\n    var defaults = {\n      follow_mount: true,\n      recurse_count: 0\n    };\n    for (var key in defaults) {\n      if (opts[key] === undefined) {\n        opts[key] = defaults[key];\n      }\n    }\n    if (opts.recurse_count > 8) {\n      throw new FS.ErrnoError(32);\n    }\n    var parts = PATH.normalizeArray(path.split("/").filter(function (p) {\n      return !!p;\n    }), false);\n    var current = FS.root;\n    var current_path = "/";\n    for (var i = 0; i < parts.length; i++) {\n      var islast = i === parts.length - 1;\n      if (islast && opts.parent) {\n        break;\n      }\n      current = FS.lookupNode(current, parts[i]);\n      current_path = PATH.join2(current_path, parts[i]);\n      if (FS.isMountpoint(current)) {\n        if (!islast || islast && opts.follow_mount) {\n          current = current.mounted.root;\n        }\n      }\n      if (!islast || opts.follow) {\n        var count = 0;\n        while (FS.isLink(current.mode)) {\n          var link = FS.readlink(current_path);\n          current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n          var lookup = FS.lookupPath(current_path, {\n            recurse_count: opts.recurse_count\n          });\n          current = lookup.node;\n          if (count++ > 40) {\n            throw new FS.ErrnoError(32);\n          }\n        }\n      }\n    }\n    return {\n      path: current_path,\n      node: current\n    };\n  },\n  getPath: function (node) {\n    var path;\n    while (true) {\n      if (FS.isRoot(node)) {\n        var mount = node.mount.mountpoint;\n        if (!path) return mount;\n        return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;\n      }\n      path = path ? node.name + "/" + path : node.name;\n      node = node.parent;\n    }\n  },\n  hashName: function (parentid, name) {\n    var hash = 0;\n    for (var i = 0; i < name.length; i++) {\n      hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n    }\n    return (parentid + hash >>> 0) % FS.nameTable.length;\n  },\n  hashAddNode: function (node) {\n    var hash = FS.hashName(node.parent.id, node.name);\n    node.name_next = FS.nameTable[hash];\n    FS.nameTable[hash] = node;\n  },\n  hashRemoveNode: function (node) {\n    var hash = FS.hashName(node.parent.id, node.name);\n    if (FS.nameTable[hash] === node) {\n      FS.nameTable[hash] = node.name_next;\n    } else {\n      var current = FS.nameTable[hash];\n      while (current) {\n        if (current.name_next === node) {\n          current.name_next = node.name_next;\n          break;\n        }\n        current = current.name_next;\n      }\n    }\n  },\n  lookupNode: function (parent, name) {\n    var errCode = FS.mayLookup(parent);\n    if (errCode) {\n      throw new FS.ErrnoError(errCode, parent);\n    }\n    var hash = FS.hashName(parent.id, name);\n    for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n      var nodeName = node.name;\n      if (node.parent.id === parent.id && nodeName === name) {\n        return node;\n      }\n    }\n    return FS.lookup(parent, name);\n  },\n  createNode: function (parent, name, mode, rdev) {\n    var node = new FS.FSNode(parent, name, mode, rdev);\n    FS.hashAddNode(node);\n    return node;\n  },\n  destroyNode: function (node) {\n    FS.hashRemoveNode(node);\n  },\n  isRoot: function (node) {\n    return node === node.parent;\n  },\n  isMountpoint: function (node) {\n    return !!node.mounted;\n  },\n  isFile: function (mode) {\n    return (mode & 61440) === 32768;\n  },\n  isDir: function (mode) {\n    return (mode & 61440) === 16384;\n  },\n  isLink: function (mode) {\n    return (mode & 61440) === 40960;\n  },\n  isChrdev: function (mode) {\n    return (mode & 61440) === 8192;\n  },\n  isBlkdev: function (mode) {\n    return (mode & 61440) === 24576;\n  },\n  isFIFO: function (mode) {\n    return (mode & 61440) === 4096;\n  },\n  isSocket: function (mode) {\n    return (mode & 49152) === 49152;\n  },\n  flagModes: {\n    "r": 0,\n    "rs": 1052672,\n    "r+": 2,\n    "w": 577,\n    "wx": 705,\n    "xw": 705,\n    "w+": 578,\n    "wx+": 706,\n    "xw+": 706,\n    "a": 1089,\n    "ax": 1217,\n    "xa": 1217,\n    "a+": 1090,\n    "ax+": 1218,\n    "xa+": 1218\n  },\n  modeStringToFlags: function (str) {\n    var flags = FS.flagModes[str];\n    if (typeof flags === "undefined") {\n      throw new Error("Unknown file open mode: " + str);\n    }\n    return flags;\n  },\n  flagsToPermissionString: function (flag) {\n    var perms = ["r", "w", "rw"][flag & 3];\n    if (flag & 512) {\n      perms += "w";\n    }\n    return perms;\n  },\n  nodePermissions: function (node, perms) {\n    if (FS.ignorePermissions) {\n      return 0;\n    }\n    if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {\n      return 2;\n    } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {\n      return 2;\n    } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {\n      return 2;\n    }\n    return 0;\n  },\n  mayLookup: function (dir) {\n    var errCode = FS.nodePermissions(dir, "x");\n    if (errCode) return errCode;\n    if (!dir.node_ops.lookup) return 2;\n    return 0;\n  },\n  mayCreate: function (dir, name) {\n    try {\n      var node = FS.lookupNode(dir, name);\n      return 20;\n    } catch (e) {}\n    return FS.nodePermissions(dir, "wx");\n  },\n  mayDelete: function (dir, name, isdir) {\n    var node;\n    try {\n      node = FS.lookupNode(dir, name);\n    } catch (e) {\n      return e.errno;\n    }\n    var errCode = FS.nodePermissions(dir, "wx");\n    if (errCode) {\n      return errCode;\n    }\n    if (isdir) {\n      if (!FS.isDir(node.mode)) {\n        return 54;\n      }\n      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n        return 10;\n      }\n    } else {\n      if (FS.isDir(node.mode)) {\n        return 31;\n      }\n    }\n    return 0;\n  },\n  mayOpen: function (node, flags) {\n    if (!node) {\n      return 44;\n    }\n    if (FS.isLink(node.mode)) {\n      return 32;\n    } else if (FS.isDir(node.mode)) {\n      if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {\n        return 31;\n      }\n    }\n    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n  },\n  MAX_OPEN_FDS: 4096,\n  nextfd: function (fd_start, fd_end) {\n    fd_start = fd_start || 0;\n    fd_end = fd_end || FS.MAX_OPEN_FDS;\n    for (var fd = fd_start; fd <= fd_end; fd++) {\n      if (!FS.streams[fd]) {\n        return fd;\n      }\n    }\n    throw new FS.ErrnoError(33);\n  },\n  getStream: function (fd) {\n    return FS.streams[fd];\n  },\n  createStream: function (stream, fd_start, fd_end) {\n    if (!FS.FSStream) {\n      FS.FSStream = function () {};\n      FS.FSStream.prototype = {\n        object: {\n          get: function () {\n            return this.node;\n          },\n          set: function (val) {\n            this.node = val;\n          }\n        },\n        isRead: {\n          get: function () {\n            return (this.flags & 2097155) !== 1;\n          }\n        },\n        isWrite: {\n          get: function () {\n            return (this.flags & 2097155) !== 0;\n          }\n        },\n        isAppend: {\n          get: function () {\n            return this.flags & 1024;\n          }\n        }\n      };\n    }\n    var newStream = new FS.FSStream();\n    for (var p in stream) {\n      newStream[p] = stream[p];\n    }\n    stream = newStream;\n    var fd = FS.nextfd(fd_start, fd_end);\n    stream.fd = fd;\n    FS.streams[fd] = stream;\n    return stream;\n  },\n  closeStream: function (fd) {\n    FS.streams[fd] = null;\n  },\n  chrdev_stream_ops: {\n    open: function (stream) {\n      var device = FS.getDevice(stream.node.rdev);\n      stream.stream_ops = device.stream_ops;\n      if (stream.stream_ops.open) {\n        stream.stream_ops.open(stream);\n      }\n    },\n    llseek: function () {\n      throw new FS.ErrnoError(70);\n    }\n  },\n  major: function (dev) {\n    return dev >> 8;\n  },\n  minor: function (dev) {\n    return dev & 255;\n  },\n  makedev: function (ma, mi) {\n    return ma << 8 | mi;\n  },\n  registerDevice: function (dev, ops) {\n    FS.devices[dev] = {\n      stream_ops: ops\n    };\n  },\n  getDevice: function (dev) {\n    return FS.devices[dev];\n  },\n  getMounts: function (mount) {\n    var mounts = [];\n    var check = [mount];\n    while (check.length) {\n      var m = check.pop();\n      mounts.push(m);\n      check.push.apply(check, m.mounts);\n    }\n    return mounts;\n  },\n  syncfs: function (populate, callback) {\n    if (typeof populate === "function") {\n      callback = populate;\n      populate = false;\n    }\n    FS.syncFSRequests++;\n    if (FS.syncFSRequests > 1) {\n      err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");\n    }\n    var mounts = FS.getMounts(FS.root.mount);\n    var completed = 0;\n    function doCallback(errCode) {\n      FS.syncFSRequests--;\n      return callback(errCode);\n    }\n    function done(errCode) {\n      if (errCode) {\n        if (!done.errored) {\n          done.errored = true;\n          return doCallback(errCode);\n        }\n        return;\n      }\n      if (++completed >= mounts.length) {\n        doCallback(null);\n      }\n    }\n    mounts.forEach(function (mount) {\n      if (!mount.type.syncfs) {\n        return done(null);\n      }\n      mount.type.syncfs(mount, populate, done);\n    });\n  },\n  mount: function (type, opts, mountpoint) {\n    var root = mountpoint === "/";\n    var pseudo = !mountpoint;\n    var node;\n    if (root && FS.root) {\n      throw new FS.ErrnoError(10);\n    } else if (!root && !pseudo) {\n      var lookup = FS.lookupPath(mountpoint, {\n        follow_mount: false\n      });\n      mountpoint = lookup.path;\n      node = lookup.node;\n      if (FS.isMountpoint(node)) {\n        throw new FS.ErrnoError(10);\n      }\n      if (!FS.isDir(node.mode)) {\n        throw new FS.ErrnoError(54);\n      }\n    }\n    var mount = {\n      type: type,\n      opts: opts,\n      mountpoint: mountpoint,\n      mounts: []\n    };\n    var mountRoot = type.mount(mount);\n    mountRoot.mount = mount;\n    mount.root = mountRoot;\n    if (root) {\n      FS.root = mountRoot;\n    } else if (node) {\n      node.mounted = mount;\n      if (node.mount) {\n        node.mount.mounts.push(mount);\n      }\n    }\n    return mountRoot;\n  },\n  unmount: function (mountpoint) {\n    var lookup = FS.lookupPath(mountpoint, {\n      follow_mount: false\n    });\n    if (!FS.isMountpoint(lookup.node)) {\n      throw new FS.ErrnoError(28);\n    }\n    var node = lookup.node;\n    var mount = node.mounted;\n    var mounts = FS.getMounts(mount);\n    Object.keys(FS.nameTable).forEach(function (hash) {\n      var current = FS.nameTable[hash];\n      while (current) {\n        var next = current.name_next;\n        if (mounts.indexOf(current.mount) !== -1) {\n          FS.destroyNode(current);\n        }\n        current = next;\n      }\n    });\n    node.mounted = null;\n    var idx = node.mount.mounts.indexOf(mount);\n    node.mount.mounts.splice(idx, 1);\n  },\n  lookup: function (parent, name) {\n    return parent.node_ops.lookup(parent, name);\n  },\n  mknod: function (path, mode, dev) {\n    var lookup = FS.lookupPath(path, {\n      parent: true\n    });\n    var parent = lookup.node;\n    var name = PATH.basename(path);\n    if (!name || name === "." || name === "..") {\n      throw new FS.ErrnoError(28);\n    }\n    var errCode = FS.mayCreate(parent, name);\n    if (errCode) {\n      throw new FS.ErrnoError(errCode);\n    }\n    if (!parent.node_ops.mknod) {\n      throw new FS.ErrnoError(63);\n    }\n    return parent.node_ops.mknod(parent, name, mode, dev);\n  },\n  create: function (path, mode) {\n    mode = mode !== undefined ? mode : 438;\n    mode &= 4095;\n    mode |= 32768;\n    return FS.mknod(path, mode, 0);\n  },\n  mkdir: function (path, mode) {\n    mode = mode !== undefined ? mode : 511;\n    mode &= 511 | 512;\n    mode |= 16384;\n    return FS.mknod(path, mode, 0);\n  },\n  mkdirTree: function (path, mode) {\n    var dirs = path.split("/");\n    var d = "";\n    for (var i = 0; i < dirs.length; ++i) {\n      if (!dirs[i]) continue;\n      d += "/" + dirs[i];\n      try {\n        FS.mkdir(d, mode);\n      } catch (e) {\n        if (e.errno != 20) throw e;\n      }\n    }\n  },\n  mkdev: function (path, mode, dev) {\n    if (typeof dev === "undefined") {\n      dev = mode;\n      mode = 438;\n    }\n    mode |= 8192;\n    return FS.mknod(path, mode, dev);\n  },\n  symlink: function (oldpath, newpath) {\n    if (!PATH_FS.resolve(oldpath)) {\n      throw new FS.ErrnoError(44);\n    }\n    var lookup = FS.lookupPath(newpath, {\n      parent: true\n    });\n    var parent = lookup.node;\n    if (!parent) {\n      throw new FS.ErrnoError(44);\n    }\n    var newname = PATH.basename(newpath);\n    var errCode = FS.mayCreate(parent, newname);\n    if (errCode) {\n      throw new FS.ErrnoError(errCode);\n    }\n    if (!parent.node_ops.symlink) {\n      throw new FS.ErrnoError(63);\n    }\n    return parent.node_ops.symlink(parent, newname, oldpath);\n  },\n  rename: function (old_path, new_path) {\n    var old_dirname = PATH.dirname(old_path);\n    var new_dirname = PATH.dirname(new_path);\n    var old_name = PATH.basename(old_path);\n    var new_name = PATH.basename(new_path);\n    var lookup, old_dir, new_dir;\n    try {\n      lookup = FS.lookupPath(old_path, {\n        parent: true\n      });\n      old_dir = lookup.node;\n      lookup = FS.lookupPath(new_path, {\n        parent: true\n      });\n      new_dir = lookup.node;\n    } catch (e) {\n      throw new FS.ErrnoError(10);\n    }\n    if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n    if (old_dir.mount !== new_dir.mount) {\n      throw new FS.ErrnoError(75);\n    }\n    var old_node = FS.lookupNode(old_dir, old_name);\n    var relative = PATH_FS.relative(old_path, new_dirname);\n    if (relative.charAt(0) !== ".") {\n      throw new FS.ErrnoError(28);\n    }\n    relative = PATH_FS.relative(new_path, old_dirname);\n    if (relative.charAt(0) !== ".") {\n      throw new FS.ErrnoError(55);\n    }\n    var new_node;\n    try {\n      new_node = FS.lookupNode(new_dir, new_name);\n    } catch (e) {}\n    if (old_node === new_node) {\n      return;\n    }\n    var isdir = FS.isDir(old_node.mode);\n    var errCode = FS.mayDelete(old_dir, old_name, isdir);\n    if (errCode) {\n      throw new FS.ErrnoError(errCode);\n    }\n    errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n    if (errCode) {\n      throw new FS.ErrnoError(errCode);\n    }\n    if (!old_dir.node_ops.rename) {\n      throw new FS.ErrnoError(63);\n    }\n    if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n      throw new FS.ErrnoError(10);\n    }\n    if (new_dir !== old_dir) {\n      errCode = FS.nodePermissions(old_dir, "w");\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n    }\n    try {\n      if (FS.trackingDelegate["willMovePath"]) {\n        FS.trackingDelegate["willMovePath"](old_path, new_path);\n      }\n    } catch (e) {\n      err("FS.trackingDelegate[\'willMovePath\'](\'" + old_path + "\', \'" + new_path + "\') threw an exception: " + e.message);\n    }\n    FS.hashRemoveNode(old_node);\n    try {\n      old_dir.node_ops.rename(old_node, new_dir, new_name);\n    } catch (e) {\n      throw e;\n    } finally {\n      FS.hashAddNode(old_node);\n    }\n    try {\n      if (FS.trackingDelegate["onMovePath"]) FS.trackingDelegate["onMovePath"](old_path, new_path);\n    } catch (e) {\n      err("FS.trackingDelegate[\'onMovePath\'](\'" + old_path + "\', \'" + new_path + "\') threw an exception: " + e.message);\n    }\n  },\n  rmdir: function (path) {\n    var lookup = FS.lookupPath(path, {\n      parent: true\n    });\n    var parent = lookup.node;\n    var name = PATH.basename(path);\n    var node = FS.lookupNode(parent, name);\n    var errCode = FS.mayDelete(parent, name, true);\n    if (errCode) {\n      throw new FS.ErrnoError(errCode);\n    }\n    if (!parent.node_ops.rmdir) {\n      throw new FS.ErrnoError(63);\n    }\n    if (FS.isMountpoint(node)) {\n      throw new FS.ErrnoError(10);\n    }\n    try {\n      if (FS.trackingDelegate["willDeletePath"]) {\n        FS.trackingDelegate["willDeletePath"](path);\n      }\n    } catch (e) {\n      err("FS.trackingDelegate[\'willDeletePath\'](\'" + path + "\') threw an exception: " + e.message);\n    }\n    parent.node_ops.rmdir(parent, name);\n    FS.destroyNode(node);\n    try {\n      if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);\n    } catch (e) {\n      err("FS.trackingDelegate[\'onDeletePath\'](\'" + path + "\') threw an exception: " + e.message);\n    }\n  },\n  readdir: function (path) {\n    var lookup = FS.lookupPath(path, {\n      follow: true\n    });\n    var node = lookup.node;\n    if (!node.node_ops.readdir) {\n      throw new FS.ErrnoError(54);\n    }\n    return node.node_ops.readdir(node);\n  },\n  unlink: function (path) {\n    var lookup = FS.lookupPath(path, {\n      parent: true\n    });\n    var parent = lookup.node;\n    var name = PATH.basename(path);\n    var node = FS.lookupNode(parent, name);\n    var errCode = FS.mayDelete(parent, name, false);\n    if (errCode) {\n      throw new FS.ErrnoError(errCode);\n    }\n    if (!parent.node_ops.unlink) {\n      throw new FS.ErrnoError(63);\n    }\n    if (FS.isMountpoint(node)) {\n      throw new FS.ErrnoError(10);\n    }\n    try {\n      if (FS.trackingDelegate["willDeletePath"]) {\n        FS.trackingDelegate["willDeletePath"](path);\n      }\n    } catch (e) {\n      err("FS.trackingDelegate[\'willDeletePath\'](\'" + path + "\') threw an exception: " + e.message);\n    }\n    parent.node_ops.unlink(parent, name);\n    FS.destroyNode(node);\n    try {\n      if (FS.trackingDelegate["onDeletePath"]) FS.trackingDelegate["onDeletePath"](path);\n    } catch (e) {\n      err("FS.trackingDelegate[\'onDeletePath\'](\'" + path + "\') threw an exception: " + e.message);\n    }\n  },\n  readlink: function (path) {\n    var lookup = FS.lookupPath(path);\n    var link = lookup.node;\n    if (!link) {\n      throw new FS.ErrnoError(44);\n    }\n    if (!link.node_ops.readlink) {\n      throw new FS.ErrnoError(28);\n    }\n    return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n  },\n  stat: function (path, dontFollow) {\n    var lookup = FS.lookupPath(path, {\n      follow: !dontFollow\n    });\n    var node = lookup.node;\n    if (!node) {\n      throw new FS.ErrnoError(44);\n    }\n    if (!node.node_ops.getattr) {\n      throw new FS.ErrnoError(63);\n    }\n    return node.node_ops.getattr(node);\n  },\n  lstat: function (path) {\n    return FS.stat(path, true);\n  },\n  chmod: function (path, mode, dontFollow) {\n    var node;\n    if (typeof path === "string") {\n      var lookup = FS.lookupPath(path, {\n        follow: !dontFollow\n      });\n      node = lookup.node;\n    } else {\n      node = path;\n    }\n    if (!node.node_ops.setattr) {\n      throw new FS.ErrnoError(63);\n    }\n    node.node_ops.setattr(node, {\n      mode: mode & 4095 | node.mode & ~4095,\n      timestamp: Date.now()\n    });\n  },\n  lchmod: function (path, mode) {\n    FS.chmod(path, mode, true);\n  },\n  fchmod: function (fd, mode) {\n    var stream = FS.getStream(fd);\n    if (!stream) {\n      throw new FS.ErrnoError(8);\n    }\n    FS.chmod(stream.node, mode);\n  },\n  chown: function (path, uid, gid, dontFollow) {\n    var node;\n    if (typeof path === "string") {\n      var lookup = FS.lookupPath(path, {\n        follow: !dontFollow\n      });\n      node = lookup.node;\n    } else {\n      node = path;\n    }\n    if (!node.node_ops.setattr) {\n      throw new FS.ErrnoError(63);\n    }\n    node.node_ops.setattr(node, {\n      timestamp: Date.now()\n    });\n  },\n  lchown: function (path, uid, gid) {\n    FS.chown(path, uid, gid, true);\n  },\n  fchown: function (fd, uid, gid) {\n    var stream = FS.getStream(fd);\n    if (!stream) {\n      throw new FS.ErrnoError(8);\n    }\n    FS.chown(stream.node, uid, gid);\n  },\n  truncate: function (path, len) {\n    if (len < 0) {\n      throw new FS.ErrnoError(28);\n    }\n    var node;\n    if (typeof path === "string") {\n      var lookup = FS.lookupPath(path, {\n        follow: true\n      });\n      node = lookup.node;\n    } else {\n      node = path;\n    }\n    if (!node.node_ops.setattr) {\n      throw new FS.ErrnoError(63);\n    }\n    if (FS.isDir(node.mode)) {\n      throw new FS.ErrnoError(31);\n    }\n    if (!FS.isFile(node.mode)) {\n      throw new FS.ErrnoError(28);\n    }\n    var errCode = FS.nodePermissions(node, "w");\n    if (errCode) {\n      throw new FS.ErrnoError(errCode);\n    }\n    node.node_ops.setattr(node, {\n      size: len,\n      timestamp: Date.now()\n    });\n  },\n  ftruncate: function (fd, len) {\n    var stream = FS.getStream(fd);\n    if (!stream) {\n      throw new FS.ErrnoError(8);\n    }\n    if ((stream.flags & 2097155) === 0) {\n      throw new FS.ErrnoError(28);\n    }\n    FS.truncate(stream.node, len);\n  },\n  utime: function (path, atime, mtime) {\n    var lookup = FS.lookupPath(path, {\n      follow: true\n    });\n    var node = lookup.node;\n    node.node_ops.setattr(node, {\n      timestamp: Math.max(atime, mtime)\n    });\n  },\n  open: function (path, flags, mode, fd_start, fd_end) {\n    if (path === "") {\n      throw new FS.ErrnoError(44);\n    }\n    flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;\n    mode = typeof mode === "undefined" ? 438 : mode;\n    if (flags & 64) {\n      mode = mode & 4095 | 32768;\n    } else {\n      mode = 0;\n    }\n    var node;\n    if (typeof path === "object") {\n      node = path;\n    } else {\n      path = PATH.normalize(path);\n      try {\n        var lookup = FS.lookupPath(path, {\n          follow: !(flags & 131072)\n        });\n        node = lookup.node;\n      } catch (e) {}\n    }\n    var created = false;\n    if (flags & 64) {\n      if (node) {\n        if (flags & 128) {\n          throw new FS.ErrnoError(20);\n        }\n      } else {\n        node = FS.mknod(path, mode, 0);\n        created = true;\n      }\n    }\n    if (!node) {\n      throw new FS.ErrnoError(44);\n    }\n    if (FS.isChrdev(node.mode)) {\n      flags &= ~512;\n    }\n    if (flags & 65536 && !FS.isDir(node.mode)) {\n      throw new FS.ErrnoError(54);\n    }\n    if (!created) {\n      var errCode = FS.mayOpen(node, flags);\n      if (errCode) {\n        throw new FS.ErrnoError(errCode);\n      }\n    }\n    if (flags & 512) {\n      FS.truncate(node, 0);\n    }\n    flags &= ~(128 | 512 | 131072);\n    var stream = FS.createStream({\n      node: node,\n      path: FS.getPath(node),\n      flags: flags,\n      seekable: true,\n      position: 0,\n      stream_ops: node.stream_ops,\n      ungotten: [],\n      error: false\n    }, fd_start, fd_end);\n    if (stream.stream_ops.open) {\n      stream.stream_ops.open(stream);\n    }\n    if (Module["logReadFiles"] && !(flags & 1)) {\n      if (!FS.readFiles) FS.readFiles = {};\n      if (!(path in FS.readFiles)) {\n        FS.readFiles[path] = 1;\n        err("FS.trackingDelegate error on read file: " + path);\n      }\n    }\n    try {\n      if (FS.trackingDelegate["onOpenFile"]) {\n        var trackingFlags = 0;\n        if ((flags & 2097155) !== 1) {\n          trackingFlags |= FS.tracking.openFlags.READ;\n        }\n        if ((flags & 2097155) !== 0) {\n          trackingFlags |= FS.tracking.openFlags.WRITE;\n        }\n        FS.trackingDelegate["onOpenFile"](path, trackingFlags);\n      }\n    } catch (e) {\n      err("FS.trackingDelegate[\'onOpenFile\'](\'" + path + "\', flags) threw an exception: " + e.message);\n    }\n    return stream;\n  },\n  close: function (stream) {\n    if (FS.isClosed(stream)) {\n      throw new FS.ErrnoError(8);\n    }\n    if (stream.getdents) stream.getdents = null;\n    try {\n      if (stream.stream_ops.close) {\n        stream.stream_ops.close(stream);\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      FS.closeStream(stream.fd);\n    }\n    stream.fd = null;\n  },\n  isClosed: function (stream) {\n    return stream.fd === null;\n  },\n  llseek: function (stream, offset, whence) {\n    if (FS.isClosed(stream)) {\n      throw new FS.ErrnoError(8);\n    }\n    if (!stream.seekable || !stream.stream_ops.llseek) {\n      throw new FS.ErrnoError(70);\n    }\n    if (whence != 0 && whence != 1 && whence != 2) {\n      throw new FS.ErrnoError(28);\n    }\n    stream.position = stream.stream_ops.llseek(stream, offset, whence);\n    stream.ungotten = [];\n    return stream.position;\n  },\n  read: function (stream, buffer, offset, length, position) {\n    if (length < 0 || position < 0) {\n      throw new FS.ErrnoError(28);\n    }\n    if (FS.isClosed(stream)) {\n      throw new FS.ErrnoError(8);\n    }\n    if ((stream.flags & 2097155) === 1) {\n      throw new FS.ErrnoError(8);\n    }\n    if (FS.isDir(stream.node.mode)) {\n      throw new FS.ErrnoError(31);\n    }\n    if (!stream.stream_ops.read) {\n      throw new FS.ErrnoError(28);\n    }\n    var seeking = typeof position !== "undefined";\n    if (!seeking) {\n      position = stream.position;\n    } else if (!stream.seekable) {\n      throw new FS.ErrnoError(70);\n    }\n    var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n    if (!seeking) stream.position += bytesRead;\n    return bytesRead;\n  },\n  write: function (stream, buffer, offset, length, position, canOwn) {\n    if (length < 0 || position < 0) {\n      throw new FS.ErrnoError(28);\n    }\n    if (FS.isClosed(stream)) {\n      throw new FS.ErrnoError(8);\n    }\n    if ((stream.flags & 2097155) === 0) {\n      throw new FS.ErrnoError(8);\n    }\n    if (FS.isDir(stream.node.mode)) {\n      throw new FS.ErrnoError(31);\n    }\n    if (!stream.stream_ops.write) {\n      throw new FS.ErrnoError(28);\n    }\n    if (stream.seekable && stream.flags & 1024) {\n      FS.llseek(stream, 0, 2);\n    }\n    var seeking = typeof position !== "undefined";\n    if (!seeking) {\n      position = stream.position;\n    } else if (!stream.seekable) {\n      throw new FS.ErrnoError(70);\n    }\n    var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n    if (!seeking) stream.position += bytesWritten;\n    try {\n      if (stream.path && FS.trackingDelegate["onWriteToFile"]) FS.trackingDelegate["onWriteToFile"](stream.path);\n    } catch (e) {\n      err("FS.trackingDelegate[\'onWriteToFile\'](\'" + stream.path + "\') threw an exception: " + e.message);\n    }\n    return bytesWritten;\n  },\n  allocate: function (stream, offset, length) {\n    if (FS.isClosed(stream)) {\n      throw new FS.ErrnoError(8);\n    }\n    if (offset < 0 || length <= 0) {\n      throw new FS.ErrnoError(28);\n    }\n    if ((stream.flags & 2097155) === 0) {\n      throw new FS.ErrnoError(8);\n    }\n    if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n      throw new FS.ErrnoError(43);\n    }\n    if (!stream.stream_ops.allocate) {\n      throw new FS.ErrnoError(138);\n    }\n    stream.stream_ops.allocate(stream, offset, length);\n  },\n  mmap: function (stream, buffer, offset, length, position, prot, flags) {\n    if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n      throw new FS.ErrnoError(2);\n    }\n    if ((stream.flags & 2097155) === 1) {\n      throw new FS.ErrnoError(2);\n    }\n    if (!stream.stream_ops.mmap) {\n      throw new FS.ErrnoError(43);\n    }\n    return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\n  },\n  msync: function (stream, buffer, offset, length, mmapFlags) {\n    if (!stream || !stream.stream_ops.msync) {\n      return 0;\n    }\n    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n  },\n  munmap: function (stream) {\n    return 0;\n  },\n  ioctl: function (stream, cmd, arg) {\n    if (!stream.stream_ops.ioctl) {\n      throw new FS.ErrnoError(59);\n    }\n    return stream.stream_ops.ioctl(stream, cmd, arg);\n  },\n  readFile: function (path, opts) {\n    opts = opts || {};\n    opts.flags = opts.flags || "r";\n    opts.encoding = opts.encoding || "binary";\n    if (opts.encoding !== "utf8" && opts.encoding !== "binary") {\n      throw new Error(\'Invalid encoding type "\' + opts.encoding + \'"\');\n    }\n    var ret;\n    var stream = FS.open(path, opts.flags);\n    var stat = FS.stat(path);\n    var length = stat.size;\n    var buf = new Uint8Array(length);\n    FS.read(stream, buf, 0, length, 0);\n    if (opts.encoding === "utf8") {\n      ret = UTF8ArrayToString(buf, 0);\n    } else if (opts.encoding === "binary") {\n      ret = buf;\n    }\n    FS.close(stream);\n    return ret;\n  },\n  writeFile: function (path, data, opts) {\n    opts = opts || {};\n    opts.flags = opts.flags || "w";\n    var stream = FS.open(path, opts.flags, opts.mode);\n    if (typeof data === "string") {\n      var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n      var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n      FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n    } else if (ArrayBuffer.isView(data)) {\n      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n    } else {\n      throw new Error("Unsupported data type");\n    }\n    FS.close(stream);\n  },\n  cwd: function () {\n    return FS.currentPath;\n  },\n  chdir: function (path) {\n    var lookup = FS.lookupPath(path, {\n      follow: true\n    });\n    if (lookup.node === null) {\n      throw new FS.ErrnoError(44);\n    }\n    if (!FS.isDir(lookup.node.mode)) {\n      throw new FS.ErrnoError(54);\n    }\n    var errCode = FS.nodePermissions(lookup.node, "x");\n    if (errCode) {\n      throw new FS.ErrnoError(errCode);\n    }\n    FS.currentPath = lookup.path;\n  },\n  createDefaultDirectories: function () {\n    FS.mkdir("/tmp");\n    FS.mkdir("/home");\n    FS.mkdir("/home/web_user");\n  },\n  createDefaultDevices: function () {\n    FS.mkdir("/dev");\n    FS.registerDevice(FS.makedev(1, 3), {\n      read: function () {\n        return 0;\n      },\n      write: function (stream, buffer, offset, length, pos) {\n        return length;\n      }\n    });\n    FS.mkdev("/dev/null", FS.makedev(1, 3));\n    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n    FS.mkdev("/dev/tty", FS.makedev(5, 0));\n    FS.mkdev("/dev/tty1", FS.makedev(6, 0));\n    var random_device;\n    if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {\n      var randomBuffer = new Uint8Array(1);\n      random_device = function () {\n        crypto.getRandomValues(randomBuffer);\n        return randomBuffer[0];\n      };\n    } else if (ENVIRONMENT_IS_NODE) {\n      try {\n        var crypto_module = require("crypto");\n        random_device = function () {\n          return crypto_module["randomBytes"](1)[0];\n        };\n      } catch (e) {}\n    } else {}\n    if (!random_device) {\n      random_device = function () {\n        abort("random_device");\n      };\n    }\n    FS.createDevice("/dev", "random", random_device);\n    FS.createDevice("/dev", "urandom", random_device);\n    FS.mkdir("/dev/shm");\n    FS.mkdir("/dev/shm/tmp");\n  },\n  createSpecialDirectories: function () {\n    FS.mkdir("/proc");\n    FS.mkdir("/proc/self");\n    FS.mkdir("/proc/self/fd");\n    FS.mount({\n      mount: function () {\n        var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);\n        node.node_ops = {\n          lookup: function (parent, name) {\n            var fd = +name;\n            var stream = FS.getStream(fd);\n            if (!stream) throw new FS.ErrnoError(8);\n            var ret = {\n              parent: null,\n              mount: {\n                mountpoint: "fake"\n              },\n              node_ops: {\n                readlink: function () {\n                  return stream.path;\n                }\n              }\n            };\n            ret.parent = ret;\n            return ret;\n          }\n        };\n        return node;\n      }\n    }, {}, "/proc/self/fd");\n  },\n  createStandardStreams: function () {\n    if (Module["stdin"]) {\n      FS.createDevice("/dev", "stdin", Module["stdin"]);\n    } else {\n      FS.symlink("/dev/tty", "/dev/stdin");\n    }\n    if (Module["stdout"]) {\n      FS.createDevice("/dev", "stdout", null, Module["stdout"]);\n    } else {\n      FS.symlink("/dev/tty", "/dev/stdout");\n    }\n    if (Module["stderr"]) {\n      FS.createDevice("/dev", "stderr", null, Module["stderr"]);\n    } else {\n      FS.symlink("/dev/tty1", "/dev/stderr");\n    }\n    var stdin = FS.open("/dev/stdin", "r");\n    var stdout = FS.open("/dev/stdout", "w");\n    var stderr = FS.open("/dev/stderr", "w");\n  },\n  ensureErrnoError: function () {\n    if (FS.ErrnoError) return;\n    FS.ErrnoError = function ErrnoError(errno, node) {\n      this.node = node;\n      this.setErrno = function (errno) {\n        this.errno = errno;\n      };\n      this.setErrno(errno);\n      this.message = "FS error";\n    };\n    FS.ErrnoError.prototype = new Error();\n    FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n    [44].forEach(function (code) {\n      FS.genericErrors[code] = new FS.ErrnoError(code);\n      FS.genericErrors[code].stack = "<generic error, no stack>";\n    });\n  },\n  staticInit: function () {\n    FS.ensureErrnoError();\n    FS.nameTable = new Array(4096);\n    FS.mount(MEMFS, {}, "/");\n    FS.createDefaultDirectories();\n    FS.createDefaultDevices();\n    FS.createSpecialDirectories();\n    FS.filesystems = {\n      "MEMFS": MEMFS\n    };\n  },\n  init: function (input, output, error) {\n    FS.init.initialized = true;\n    FS.ensureErrnoError();\n    Module["stdin"] = input || Module["stdin"];\n    Module["stdout"] = output || Module["stdout"];\n    Module["stderr"] = error || Module["stderr"];\n    FS.createStandardStreams();\n  },\n  quit: function () {\n    FS.init.initialized = false;\n    var fflush = Module["_fflush"];\n    if (fflush) fflush(0);\n    for (var i = 0; i < FS.streams.length; i++) {\n      var stream = FS.streams[i];\n      if (!stream) {\n        continue;\n      }\n      FS.close(stream);\n    }\n  },\n  getMode: function (canRead, canWrite) {\n    var mode = 0;\n    if (canRead) mode |= 292 | 73;\n    if (canWrite) mode |= 146;\n    return mode;\n  },\n  joinPath: function (parts, forceRelative) {\n    var path = PATH.join.apply(null, parts);\n    if (forceRelative && path[0] == "/") path = path.substr(1);\n    return path;\n  },\n  absolutePath: function (relative, base) {\n    return PATH_FS.resolve(base, relative);\n  },\n  standardizePath: function (path) {\n    return PATH.normalize(path);\n  },\n  findObject: function (path, dontResolveLastLink) {\n    var ret = FS.analyzePath(path, dontResolveLastLink);\n    if (ret.exists) {\n      return ret.object;\n    } else {\n      setErrNo(ret.error);\n      return null;\n    }\n  },\n  analyzePath: function (path, dontResolveLastLink) {\n    try {\n      var lookup = FS.lookupPath(path, {\n        follow: !dontResolveLastLink\n      });\n      path = lookup.path;\n    } catch (e) {}\n    var ret = {\n      isRoot: false,\n      exists: false,\n      error: 0,\n      name: null,\n      path: null,\n      object: null,\n      parentExists: false,\n      parentPath: null,\n      parentObject: null\n    };\n    try {\n      var lookup = FS.lookupPath(path, {\n        parent: true\n      });\n      ret.parentExists = true;\n      ret.parentPath = lookup.path;\n      ret.parentObject = lookup.node;\n      ret.name = PATH.basename(path);\n      lookup = FS.lookupPath(path, {\n        follow: !dontResolveLastLink\n      });\n      ret.exists = true;\n      ret.path = lookup.path;\n      ret.object = lookup.node;\n      ret.name = lookup.node.name;\n      ret.isRoot = lookup.path === "/";\n    } catch (e) {\n      ret.error = e.errno;\n    }\n    return ret;\n  },\n  createFolder: function (parent, name, canRead, canWrite) {\n    var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);\n    var mode = FS.getMode(canRead, canWrite);\n    return FS.mkdir(path, mode);\n  },\n  createPath: function (parent, path, canRead, canWrite) {\n    parent = typeof parent === "string" ? parent : FS.getPath(parent);\n    var parts = path.split("/").reverse();\n    while (parts.length) {\n      var part = parts.pop();\n      if (!part) continue;\n      var current = PATH.join2(parent, part);\n      try {\n        FS.mkdir(current);\n      } catch (e) {}\n      parent = current;\n    }\n    return current;\n  },\n  createFile: function (parent, name, properties, canRead, canWrite) {\n    var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);\n    var mode = FS.getMode(canRead, canWrite);\n    return FS.create(path, mode);\n  },\n  createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {\n    var path = name ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name) : parent;\n    var mode = FS.getMode(canRead, canWrite);\n    var node = FS.create(path, mode);\n    if (data) {\n      if (typeof data === "string") {\n        var arr = new Array(data.length);\n        for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n        data = arr;\n      }\n      FS.chmod(node, mode | 146);\n      var stream = FS.open(node, "w");\n      FS.write(stream, data, 0, data.length, 0, canOwn);\n      FS.close(stream);\n      FS.chmod(node, mode);\n    }\n    return node;\n  },\n  createDevice: function (parent, name, input, output) {\n    var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);\n    var mode = FS.getMode(!!input, !!output);\n    if (!FS.createDevice.major) FS.createDevice.major = 64;\n    var dev = FS.makedev(FS.createDevice.major++, 0);\n    FS.registerDevice(dev, {\n      open: function (stream) {\n        stream.seekable = false;\n      },\n      close: function (stream) {\n        if (output && output.buffer && output.buffer.length) {\n          output(10);\n        }\n      },\n      read: function (stream, buffer, offset, length, pos) {\n        var bytesRead = 0;\n        for (var i = 0; i < length; i++) {\n          var result;\n          try {\n            result = input();\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (result === undefined && bytesRead === 0) {\n            throw new FS.ErrnoError(6);\n          }\n          if (result === null || result === undefined) break;\n          bytesRead++;\n          buffer[offset + i] = result;\n        }\n        if (bytesRead) {\n          stream.node.timestamp = Date.now();\n        }\n        return bytesRead;\n      },\n      write: function (stream, buffer, offset, length, pos) {\n        for (var i = 0; i < length; i++) {\n          try {\n            output(buffer[offset + i]);\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n        if (length) {\n          stream.node.timestamp = Date.now();\n        }\n        return i;\n      }\n    });\n    return FS.mkdev(path, mode, dev);\n  },\n  createLink: function (parent, name, target, canRead, canWrite) {\n    var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name);\n    return FS.symlink(target, path);\n  },\n  forceLoadFile: function (obj) {\n    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n    var success = true;\n    if (typeof XMLHttpRequest !== "undefined") {\n      throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");\n    } else if (read_) {\n      try {\n        obj.contents = intArrayFromString(read_(obj.url), true);\n        obj.usedBytes = obj.contents.length;\n      } catch (e) {\n        success = false;\n      }\n    } else {\n      throw new Error("Cannot load without read() or XMLHttpRequest.");\n    }\n    if (!success) setErrNo(29);\n    return success;\n  },\n  createLazyFile: function (parent, name, url, canRead, canWrite) {\n    function LazyUint8Array() {\n      this.lengthKnown = false;\n      this.chunks = [];\n    }\n    LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n      if (idx > this.length - 1 || idx < 0) {\n        return undefined;\n      }\n      var chunkOffset = idx % this.chunkSize;\n      var chunkNum = idx / this.chunkSize | 0;\n      return this.getter(chunkNum)[chunkOffset];\n    };\n    LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n      this.getter = getter;\n    };\n    LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n      var xhr = new XMLHttpRequest();\n      xhr.open("HEAD", url, false);\n      xhr.send(null);\n      if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn\'t load " + url + ". Status: " + xhr.status);\n      var datalength = Number(xhr.getResponseHeader("Content-length"));\n      var header;\n      var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";\n      var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";\n      var chunkSize = 1024 * 1024;\n      if (!hasByteServing) chunkSize = datalength;\n      var doXHR = function (from, to) {\n        if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");\n        if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");\n        var xhr = new XMLHttpRequest();\n        xhr.open("GET", url, false);\n        if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);\n        if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";\n        if (xhr.overrideMimeType) {\n          xhr.overrideMimeType("text/plain; charset=x-user-defined");\n        }\n        xhr.send(null);\n        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn\'t load " + url + ". Status: " + xhr.status);\n        if (xhr.response !== undefined) {\n          return new Uint8Array(xhr.response || []);\n        } else {\n          return intArrayFromString(xhr.responseText || "", true);\n        }\n      };\n      var lazyArray = this;\n      lazyArray.setDataGetter(function (chunkNum) {\n        var start = chunkNum * chunkSize;\n        var end = (chunkNum + 1) * chunkSize - 1;\n        end = Math.min(end, datalength - 1);\n        if (typeof lazyArray.chunks[chunkNum] === "undefined") {\n          lazyArray.chunks[chunkNum] = doXHR(start, end);\n        }\n        if (typeof lazyArray.chunks[chunkNum] === "undefined") throw new Error("doXHR failed!");\n        return lazyArray.chunks[chunkNum];\n      });\n      if (usesGzip || !datalength) {\n        chunkSize = datalength = 1;\n        datalength = this.getter(0).length;\n        chunkSize = datalength;\n        out("LazyFiles on gzip forces download of the whole file when length is accessed");\n      }\n      this._length = datalength;\n      this._chunkSize = chunkSize;\n      this.lengthKnown = true;\n    };\n    if (typeof XMLHttpRequest !== "undefined") {\n      if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";\n      var lazyArray = new LazyUint8Array();\n      Object.defineProperties(lazyArray, {\n        length: {\n          get: function () {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._length;\n          }\n        },\n        chunkSize: {\n          get: function () {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._chunkSize;\n          }\n        }\n      });\n      var properties = {\n        isDevice: false,\n        contents: lazyArray\n      };\n    } else {\n      var properties = {\n        isDevice: false,\n        url: url\n      };\n    }\n    var node = FS.createFile(parent, name, properties, canRead, canWrite);\n    if (properties.contents) {\n      node.contents = properties.contents;\n    } else if (properties.url) {\n      node.contents = null;\n      node.url = properties.url;\n    }\n    Object.defineProperties(node, {\n      usedBytes: {\n        get: function () {\n          return this.contents.length;\n        }\n      }\n    });\n    var stream_ops = {};\n    var keys = Object.keys(node.stream_ops);\n    keys.forEach(function (key) {\n      var fn = node.stream_ops[key];\n      stream_ops[key] = function forceLoadLazyFile() {\n        if (!FS.forceLoadFile(node)) {\n          throw new FS.ErrnoError(29);\n        }\n        return fn.apply(null, arguments);\n      };\n    });\n    stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n      if (!FS.forceLoadFile(node)) {\n        throw new FS.ErrnoError(29);\n      }\n      var contents = stream.node.contents;\n      if (position >= contents.length) return 0;\n      var size = Math.min(contents.length - position, length);\n      if (contents.slice) {\n        for (var i = 0; i < size; i++) {\n          buffer[offset + i] = contents[position + i];\n        }\n      } else {\n        for (var i = 0; i < size; i++) {\n          buffer[offset + i] = contents.get(position + i);\n        }\n      }\n      return size;\n    };\n    node.stream_ops = stream_ops;\n    return node;\n  },\n  createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n    Browser.init();\n    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n    var dep = getUniqueRunDependency("cp " + fullname);\n    function processData(byteArray) {\n      function finish(byteArray) {\n        if (preFinish) preFinish();\n        if (!dontCreateFile) {\n          FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n        }\n        if (onload) onload();\n        removeRunDependency(dep);\n      }\n      var handled = false;\n      Module["preloadPlugins"].forEach(function (plugin) {\n        if (handled) return;\n        if (plugin["canHandle"](fullname)) {\n          plugin["handle"](byteArray, fullname, finish, function () {\n            if (onerror) onerror();\n            removeRunDependency(dep);\n          });\n          handled = true;\n        }\n      });\n      if (!handled) finish(byteArray);\n    }\n    addRunDependency(dep);\n    if (typeof url == "string") {\n      Browser.asyncLoad(url, function (byteArray) {\n        processData(byteArray);\n      }, onerror);\n    } else {\n      processData(url);\n    }\n  },\n  indexedDB: function () {\n    return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n  },\n  DB_NAME: function () {\n    return "EM_FS_" + window.location.pathname;\n  },\n  DB_VERSION: 20,\n  DB_STORE_NAME: "FILE_DATA",\n  saveFilesToDB: function (paths, onload, onerror) {\n    onload = onload || function () {};\n    onerror = onerror || function () {};\n    var indexedDB = FS.indexedDB();\n    try {\n      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n    } catch (e) {\n      return onerror(e);\n    }\n    openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n      out("creating db");\n      var db = openRequest.result;\n      db.createObjectStore(FS.DB_STORE_NAME);\n    };\n    openRequest.onsuccess = function openRequest_onsuccess() {\n      var db = openRequest.result;\n      var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");\n      var files = transaction.objectStore(FS.DB_STORE_NAME);\n      var ok = 0,\n        fail = 0,\n        total = paths.length;\n      function finish() {\n        if (fail == 0) onload();else onerror();\n      }\n      paths.forEach(function (path) {\n        var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n        putRequest.onsuccess = function putRequest_onsuccess() {\n          ok++;\n          if (ok + fail == total) finish();\n        };\n        putRequest.onerror = function putRequest_onerror() {\n          fail++;\n          if (ok + fail == total) finish();\n        };\n      });\n      transaction.onerror = onerror;\n    };\n    openRequest.onerror = onerror;\n  },\n  loadFilesFromDB: function (paths, onload, onerror) {\n    onload = onload || function () {};\n    onerror = onerror || function () {};\n    var indexedDB = FS.indexedDB();\n    try {\n      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n    } catch (e) {\n      return onerror(e);\n    }\n    openRequest.onupgradeneeded = onerror;\n    openRequest.onsuccess = function openRequest_onsuccess() {\n      var db = openRequest.result;\n      try {\n        var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");\n      } catch (e) {\n        onerror(e);\n        return;\n      }\n      var files = transaction.objectStore(FS.DB_STORE_NAME);\n      var ok = 0,\n        fail = 0,\n        total = paths.length;\n      function finish() {\n        if (fail == 0) onload();else onerror();\n      }\n      paths.forEach(function (path) {\n        var getRequest = files.get(path);\n        getRequest.onsuccess = function getRequest_onsuccess() {\n          if (FS.analyzePath(path).exists) {\n            FS.unlink(path);\n          }\n          FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n          ok++;\n          if (ok + fail == total) finish();\n        };\n        getRequest.onerror = function getRequest_onerror() {\n          fail++;\n          if (ok + fail == total) finish();\n        };\n      });\n      transaction.onerror = onerror;\n    };\n    openRequest.onerror = onerror;\n  }\n};\nvar SYSCALLS = {\n  mappings: {},\n  DEFAULT_POLLMASK: 5,\n  umask: 511,\n  calculateAt: function (dirfd, path) {\n    if (path[0] !== "/") {\n      var dir;\n      if (dirfd === -100) {\n        dir = FS.cwd();\n      } else {\n        var dirstream = FS.getStream(dirfd);\n        if (!dirstream) throw new FS.ErrnoError(8);\n        dir = dirstream.path;\n      }\n      path = PATH.join2(dir, path);\n    }\n    return path;\n  },\n  doStat: function (func, path, buf) {\n    try {\n      var stat = func(path);\n    } catch (e) {\n      if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n        return -54;\n      }\n      throw e;\n    }\n    HEAP32[buf >> 2] = stat.dev;\n    HEAP32[buf + 4 >> 2] = 0;\n    HEAP32[buf + 8 >> 2] = stat.ino;\n    HEAP32[buf + 12 >> 2] = stat.mode;\n    HEAP32[buf + 16 >> 2] = stat.nlink;\n    HEAP32[buf + 20 >> 2] = stat.uid;\n    HEAP32[buf + 24 >> 2] = stat.gid;\n    HEAP32[buf + 28 >> 2] = stat.rdev;\n    HEAP32[buf + 32 >> 2] = 0;\n    tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n    HEAP32[buf + 48 >> 2] = 4096;\n    HEAP32[buf + 52 >> 2] = stat.blocks;\n    HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;\n    HEAP32[buf + 60 >> 2] = 0;\n    HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;\n    HEAP32[buf + 68 >> 2] = 0;\n    HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;\n    HEAP32[buf + 76 >> 2] = 0;\n    tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];\n    return 0;\n  },\n  doMsync: function (addr, stream, len, flags, offset) {\n    var buffer = HEAPU8.slice(addr, addr + len);\n    FS.msync(stream, buffer, offset, len, flags);\n  },\n  doMkdir: function (path, mode) {\n    path = PATH.normalize(path);\n    if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);\n    FS.mkdir(path, mode, 0);\n    return 0;\n  },\n  doMknod: function (path, mode, dev) {\n    switch (mode & 61440) {\n      case 32768:\n      case 8192:\n      case 24576:\n      case 4096:\n      case 49152:\n        break;\n      default:\n        return -28;\n    }\n    FS.mknod(path, mode, dev);\n    return 0;\n  },\n  doReadlink: function (path, buf, bufsize) {\n    if (bufsize <= 0) return -28;\n    var ret = FS.readlink(path);\n    var len = Math.min(bufsize, lengthBytesUTF8(ret));\n    var endChar = HEAP8[buf + len];\n    stringToUTF8(ret, buf, bufsize + 1);\n    HEAP8[buf + len] = endChar;\n    return len;\n  },\n  doAccess: function (path, amode) {\n    if (amode & ~7) {\n      return -28;\n    }\n    var node;\n    var lookup = FS.lookupPath(path, {\n      follow: true\n    });\n    node = lookup.node;\n    if (!node) {\n      return -44;\n    }\n    var perms = "";\n    if (amode & 4) perms += "r";\n    if (amode & 2) perms += "w";\n    if (amode & 1) perms += "x";\n    if (perms && FS.nodePermissions(node, perms)) {\n      return -2;\n    }\n    return 0;\n  },\n  doDup: function (path, flags, suggestFD) {\n    var suggest = FS.getStream(suggestFD);\n    if (suggest) FS.close(suggest);\n    return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n  },\n  doReadv: function (stream, iov, iovcnt, offset) {\n    var ret = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAP32[iov + i * 8 >> 2];\n      var len = HEAP32[iov + (i * 8 + 4) >> 2];\n      var curr = FS.read(stream, HEAP8, ptr, len, offset);\n      if (curr < 0) return -1;\n      ret += curr;\n      if (curr < len) break;\n    }\n    return ret;\n  },\n  doWritev: function (stream, iov, iovcnt, offset) {\n    var ret = 0;\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAP32[iov + i * 8 >> 2];\n      var len = HEAP32[iov + (i * 8 + 4) >> 2];\n      var curr = FS.write(stream, HEAP8, ptr, len, offset);\n      if (curr < 0) return -1;\n      ret += curr;\n    }\n    return ret;\n  },\n  varargs: undefined,\n  get: function () {\n    SYSCALLS.varargs += 4;\n    var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n    return ret;\n  },\n  getStr: function (ptr) {\n    var ret = UTF8ToString(ptr);\n    return ret;\n  },\n  getStreamFromFD: function (fd) {\n    var stream = FS.getStream(fd);\n    if (!stream) throw new FS.ErrnoError(8);\n    return stream;\n  },\n  get64: function (low, high) {\n    return low;\n  }\n};\nfunction ___sys_fcntl64(fd, cmd, varargs) {\n  SYSCALLS.varargs = varargs;\n  try {\n    var stream = SYSCALLS.getStreamFromFD(fd);\n    switch (cmd) {\n      case 0:\n        {\n          var arg = SYSCALLS.get();\n          if (arg < 0) {\n            return -28;\n          }\n          var newStream;\n          newStream = FS.open(stream.path, stream.flags, 0, arg);\n          return newStream.fd;\n        }\n      case 1:\n      case 2:\n        return 0;\n      case 3:\n        return stream.flags;\n      case 4:\n        {\n          var arg = SYSCALLS.get();\n          stream.flags |= arg;\n          return 0;\n        }\n      case 12:\n        {\n          var arg = SYSCALLS.get();\n          var offset = 0;\n          HEAP16[arg + offset >> 1] = 2;\n          return 0;\n        }\n      case 13:\n      case 14:\n        return 0;\n      case 16:\n      case 8:\n        return -28;\n      case 9:\n        setErrNo(28);\n        return -1;\n      default:\n        {\n          return -28;\n        }\n    }\n  } catch (e) {\n    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n}\nfunction ___sys_ioctl(fd, op, varargs) {\n  SYSCALLS.varargs = varargs;\n  try {\n    var stream = SYSCALLS.getStreamFromFD(fd);\n    switch (op) {\n      case 21509:\n      case 21505:\n        {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n      case 21510:\n      case 21511:\n      case 21512:\n      case 21506:\n      case 21507:\n      case 21508:\n        {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n      case 21519:\n        {\n          if (!stream.tty) return -59;\n          var argp = SYSCALLS.get();\n          HEAP32[argp >> 2] = 0;\n          return 0;\n        }\n      case 21520:\n        {\n          if (!stream.tty) return -59;\n          return -28;\n        }\n      case 21531:\n        {\n          var argp = SYSCALLS.get();\n          return FS.ioctl(stream, op, argp);\n        }\n      case 21523:\n        {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n      case 21524:\n        {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n      default:\n        abort("bad ioctl syscall " + op);\n    }\n  } catch (e) {\n    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n}\nfunction syscallMunmap(addr, len) {\n  if ((addr | 0) === -1 || len === 0) {\n    return -28;\n  }\n  var info = SYSCALLS.mappings[addr];\n  if (!info) return 0;\n  if (len === info.len) {\n    var stream = FS.getStream(info.fd);\n    if (info.prot & 2) {\n      SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);\n    }\n    FS.munmap(stream);\n    SYSCALLS.mappings[addr] = null;\n    if (info.allocated) {\n      _free(info.malloc);\n    }\n  }\n  return 0;\n}\nfunction ___sys_munmap(addr, len) {\n  try {\n    return syscallMunmap(addr, len);\n  } catch (e) {\n    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n}\nfunction ___sys_open(path, flags, varargs) {\n  SYSCALLS.varargs = varargs;\n  try {\n    var pathname = SYSCALLS.getStr(path);\n    var mode = SYSCALLS.get();\n    var stream = FS.open(pathname, flags, mode);\n    return stream.fd;\n  } catch (e) {\n    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n}\nfunction _abort() {\n  abort();\n}\nvar setjmpId = 0;\nfunction _saveSetjmp(env, label, table, size) {\n  env = env | 0;\n  label = label | 0;\n  table = table | 0;\n  size = size | 0;\n  var i = 0;\n  setjmpId = setjmpId + 1 | 0;\n  HEAP32[env >> 2] = setjmpId;\n  while ((i | 0) < (size | 0)) {\n    if ((HEAP32[table + (i << 3) >> 2] | 0) == 0) {\n      HEAP32[table + (i << 3) >> 2] = setjmpId;\n      HEAP32[table + ((i << 3) + 4) >> 2] = label;\n      HEAP32[table + ((i << 3) + 8) >> 2] = 0;\n      setTempRet0(size | 0);\n      return table | 0;\n    }\n    i = i + 1 | 0;\n  }\n  size = size * 2 | 0;\n  table = _realloc(table | 0, 8 * (size + 1 | 0) | 0) | 0;\n  table = _saveSetjmp(env | 0, label | 0, table | 0, size | 0) | 0;\n  setTempRet0(size | 0);\n  return table | 0;\n}\nfunction _testSetjmp(id, table, size) {\n  id = id | 0;\n  table = table | 0;\n  size = size | 0;\n  var i = 0,\n    curr = 0;\n  while ((i | 0) < (size | 0)) {\n    curr = HEAP32[table + (i << 3) >> 2] | 0;\n    if ((curr | 0) == 0) break;\n    if ((curr | 0) == (id | 0)) {\n      return HEAP32[table + ((i << 3) + 4) >> 2] | 0;\n    }\n    i = i + 1 | 0;\n  }\n  return 0;\n}\nfunction _longjmp(env, value) {\n  _setThrew(env, value || 1);\n  throw "longjmp";\n}\nfunction _emscripten_longjmp(env, value) {\n  _longjmp(env, value);\n}\nfunction _emscripten_memcpy_big(dest, src, num) {\n  HEAPU8.copyWithin(dest, src, src + num);\n}\nfunction _emscripten_get_heap_size() {\n  return HEAPU8.length;\n}\nfunction emscripten_realloc_buffer(size) {\n  try {\n    wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n    updateGlobalBufferAndViews(wasmMemory.buffer);\n    return 1;\n  } catch (e) {}\n}\nfunction _emscripten_resize_heap(requestedSize) {\n  requestedSize = requestedSize >>> 0;\n  var oldSize = _emscripten_get_heap_size();\n  var PAGE_MULTIPLE = 65536;\n  var maxHeapSize = 2147483648;\n  if (requestedSize > maxHeapSize) {\n    return false;\n  }\n  var minHeapSize = 16777216;\n  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n    var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));\n    var replacement = emscripten_realloc_buffer(newSize);\n    if (replacement) {\n      return true;\n    }\n  }\n  return false;\n}\nvar ENV = {};\nfunction __getExecutableName() {\n  return thisProgram || "./this.program";\n}\nfunction getEnvStrings() {\n  if (!getEnvStrings.strings) {\n    var env = {\n      "USER": "web_user",\n      "LOGNAME": "web_user",\n      "PATH": "/",\n      "PWD": "/",\n      "HOME": "/home/web_user",\n      "LANG": (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",\n      "_": __getExecutableName()\n    };\n    for (var x in ENV) {\n      env[x] = ENV[x];\n    }\n    var strings = [];\n    for (var x in env) {\n      strings.push(x + "=" + env[x]);\n    }\n    getEnvStrings.strings = strings;\n  }\n  return getEnvStrings.strings;\n}\nfunction _environ_get(__environ, environ_buf) {\n  var bufSize = 0;\n  getEnvStrings().forEach(function (string, i) {\n    var ptr = environ_buf + bufSize;\n    HEAP32[__environ + i * 4 >> 2] = ptr;\n    writeAsciiToMemory(string, ptr);\n    bufSize += string.length + 1;\n  });\n  return 0;\n}\nfunction _environ_sizes_get(penviron_count, penviron_buf_size) {\n  var strings = getEnvStrings();\n  HEAP32[penviron_count >> 2] = strings.length;\n  var bufSize = 0;\n  strings.forEach(function (string) {\n    bufSize += string.length + 1;\n  });\n  HEAP32[penviron_buf_size >> 2] = bufSize;\n  return 0;\n}\nfunction _fd_close(fd) {\n  try {\n    var stream = SYSCALLS.getStreamFromFD(fd);\n    FS.close(stream);\n    return 0;\n  } catch (e) {\n    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n}\nfunction _fd_read(fd, iov, iovcnt, pnum) {\n  try {\n    var stream = SYSCALLS.getStreamFromFD(fd);\n    var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n    HEAP32[pnum >> 2] = num;\n    return 0;\n  } catch (e) {\n    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n}\nfunction _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n  try {\n    var stream = SYSCALLS.getStreamFromFD(fd);\n    var HIGH_OFFSET = 4294967296;\n    var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);\n    var DOUBLE_LIMIT = 9007199254740992;\n    if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {\n      return -61;\n    }\n    FS.llseek(stream, offset, whence);\n    tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n    return 0;\n  } catch (e) {\n    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n}\nfunction _fd_write(fd, iov, iovcnt, pnum) {\n  try {\n    var stream = SYSCALLS.getStreamFromFD(fd);\n    var num = SYSCALLS.doWritev(stream, iov, iovcnt);\n    HEAP32[pnum >> 2] = num;\n    return 0;\n  } catch (e) {\n    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n}\nfunction _getTempRet0() {\n  return getTempRet0() | 0;\n}\nfunction _round(d) {\n  d = +d;\n  return d >= +0 ? +Math_floor(d + +.5) : +Math_ceil(d - +.5);\n}\nfunction _setTempRet0($i) {\n  setTempRet0($i | 0);\n}\nfunction __isLeapYear(year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction __arraySum(array, index) {\n  var sum = 0;\n  for (var i = 0; i <= index; sum += array[i++]) {}\n  return sum;\n}\nvar __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction __addDays(date, days) {\n  var newDate = new Date(date.getTime());\n  while (days > 0) {\n    var leap = __isLeapYear(newDate.getFullYear());\n    var currentMonth = newDate.getMonth();\n    var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n    if (days > daysInCurrentMonth - newDate.getDate()) {\n      days -= daysInCurrentMonth - newDate.getDate() + 1;\n      newDate.setDate(1);\n      if (currentMonth < 11) {\n        newDate.setMonth(currentMonth + 1);\n      } else {\n        newDate.setMonth(0);\n        newDate.setFullYear(newDate.getFullYear() + 1);\n      }\n    } else {\n      newDate.setDate(newDate.getDate() + days);\n      return newDate;\n    }\n  }\n  return newDate;\n}\nfunction _strftime(s, maxsize, format, tm) {\n  var tm_zone = HEAP32[tm + 40 >> 2];\n  var date = {\n    tm_sec: HEAP32[tm >> 2],\n    tm_min: HEAP32[tm + 4 >> 2],\n    tm_hour: HEAP32[tm + 8 >> 2],\n    tm_mday: HEAP32[tm + 12 >> 2],\n    tm_mon: HEAP32[tm + 16 >> 2],\n    tm_year: HEAP32[tm + 20 >> 2],\n    tm_wday: HEAP32[tm + 24 >> 2],\n    tm_yday: HEAP32[tm + 28 >> 2],\n    tm_isdst: HEAP32[tm + 32 >> 2],\n    tm_gmtoff: HEAP32[tm + 36 >> 2],\n    tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""\n  };\n  var pattern = UTF8ToString(format);\n  var EXPANSION_RULES_1 = {\n    "%c": "%a %b %d %H:%M:%S %Y",\n    "%D": "%m/%d/%y",\n    "%F": "%Y-%m-%d",\n    "%h": "%b",\n    "%r": "%I:%M:%S %p",\n    "%R": "%H:%M",\n    "%T": "%H:%M:%S",\n    "%x": "%m/%d/%y",\n    "%X": "%H:%M:%S",\n    "%Ec": "%c",\n    "%EC": "%C",\n    "%Ex": "%m/%d/%y",\n    "%EX": "%H:%M:%S",\n    "%Ey": "%y",\n    "%EY": "%Y",\n    "%Od": "%d",\n    "%Oe": "%e",\n    "%OH": "%H",\n    "%OI": "%I",\n    "%Om": "%m",\n    "%OM": "%M",\n    "%OS": "%S",\n    "%Ou": "%u",\n    "%OU": "%U",\n    "%OV": "%V",\n    "%Ow": "%w",\n    "%OW": "%W",\n    "%Oy": "%y"\n  };\n  for (var rule in EXPANSION_RULES_1) {\n    pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);\n  }\n  var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];\n  var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];\n  function leadingSomething(value, digits, character) {\n    var str = typeof value === "number" ? value.toString() : value || "";\n    while (str.length < digits) {\n      str = character[0] + str;\n    }\n    return str;\n  }\n  function leadingNulls(value, digits) {\n    return leadingSomething(value, digits, "0");\n  }\n  function compareByDay(date1, date2) {\n    function sgn(value) {\n      return value < 0 ? -1 : value > 0 ? 1 : 0;\n    }\n    var compare;\n    if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n      if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n        compare = sgn(date1.getDate() - date2.getDate());\n      }\n    }\n    return compare;\n  }\n  function getFirstWeekStartDate(janFourth) {\n    switch (janFourth.getDay()) {\n      case 0:\n        return new Date(janFourth.getFullYear() - 1, 11, 29);\n      case 1:\n        return janFourth;\n      case 2:\n        return new Date(janFourth.getFullYear(), 0, 3);\n      case 3:\n        return new Date(janFourth.getFullYear(), 0, 2);\n      case 4:\n        return new Date(janFourth.getFullYear(), 0, 1);\n      case 5:\n        return new Date(janFourth.getFullYear() - 1, 11, 31);\n      case 6:\n        return new Date(janFourth.getFullYear() - 1, 11, 30);\n    }\n  }\n  function getWeekBasedYear(date) {\n    var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n    var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n    var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n    var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n    var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n    if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n      if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n        return thisDate.getFullYear() + 1;\n      } else {\n        return thisDate.getFullYear();\n      }\n    } else {\n      return thisDate.getFullYear() - 1;\n    }\n  }\n  var EXPANSION_RULES_2 = {\n    "%a": function (date) {\n      return WEEKDAYS[date.tm_wday].substring(0, 3);\n    },\n    "%A": function (date) {\n      return WEEKDAYS[date.tm_wday];\n    },\n    "%b": function (date) {\n      return MONTHS[date.tm_mon].substring(0, 3);\n    },\n    "%B": function (date) {\n      return MONTHS[date.tm_mon];\n    },\n    "%C": function (date) {\n      var year = date.tm_year + 1900;\n      return leadingNulls(year / 100 | 0, 2);\n    },\n    "%d": function (date) {\n      return leadingNulls(date.tm_mday, 2);\n    },\n    "%e": function (date) {\n      return leadingSomething(date.tm_mday, 2, " ");\n    },\n    "%g": function (date) {\n      return getWeekBasedYear(date).toString().substring(2);\n    },\n    "%G": function (date) {\n      return getWeekBasedYear(date);\n    },\n    "%H": function (date) {\n      return leadingNulls(date.tm_hour, 2);\n    },\n    "%I": function (date) {\n      var twelveHour = date.tm_hour;\n      if (twelveHour == 0) twelveHour = 12;else if (twelveHour > 12) twelveHour -= 12;\n      return leadingNulls(twelveHour, 2);\n    },\n    "%j": function (date) {\n      return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\n    },\n    "%m": function (date) {\n      return leadingNulls(date.tm_mon + 1, 2);\n    },\n    "%M": function (date) {\n      return leadingNulls(date.tm_min, 2);\n    },\n    "%n": function () {\n      return "\\n";\n    },\n    "%p": function (date) {\n      if (date.tm_hour >= 0 && date.tm_hour < 12) {\n        return "AM";\n      } else {\n        return "PM";\n      }\n    },\n    "%S": function (date) {\n      return leadingNulls(date.tm_sec, 2);\n    },\n    "%t": function () {\n      return "\\t";\n    },\n    "%u": function (date) {\n      return date.tm_wday || 7;\n    },\n    "%U": function (date) {\n      var janFirst = new Date(date.tm_year + 1900, 0, 1);\n      var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\n      var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n      if (compareByDay(firstSunday, endDate) < 0) {\n        var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n        var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\n        var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n        return leadingNulls(Math.ceil(days / 7), 2);\n      }\n      return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";\n    },\n    "%V": function (date) {\n      var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\n      var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n      var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n      if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\n        return "53";\n      }\n      if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\n        return "01";\n      }\n      var daysDifference;\n      if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\n        daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();\n      } else {\n        daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();\n      }\n      return leadingNulls(Math.ceil(daysDifference / 7), 2);\n    },\n    "%w": function (date) {\n      return date.tm_wday;\n    },\n    "%W": function (date) {\n      var janFirst = new Date(date.tm_year, 0, 1);\n      var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\n      var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\n      if (compareByDay(firstMonday, endDate) < 0) {\n        var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\n        var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\n        var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\n        return leadingNulls(Math.ceil(days / 7), 2);\n      }\n      return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";\n    },\n    "%y": function (date) {\n      return (date.tm_year + 1900).toString().substring(2);\n    },\n    "%Y": function (date) {\n      return date.tm_year + 1900;\n    },\n    "%z": function (date) {\n      var off = date.tm_gmtoff;\n      var ahead = off >= 0;\n      off = Math.abs(off) / 60;\n      off = off / 60 * 100 + off % 60;\n      return (ahead ? "+" : "-") + String("0000" + off).slice(-4);\n    },\n    "%Z": function (date) {\n      return date.tm_zone;\n    },\n    "%%": function () {\n      return "%";\n    }\n  };\n  for (var rule in EXPANSION_RULES_2) {\n    if (pattern.indexOf(rule) >= 0) {\n      pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));\n    }\n  }\n  var bytes = intArrayFromString(pattern, false);\n  if (bytes.length > maxsize) {\n    return 0;\n  }\n  writeArrayToMemory(bytes, s);\n  return bytes.length - 1;\n}\nfunction _strftime_l(s, maxsize, format, tm) {\n  return _strftime(s, maxsize, format, tm);\n}\nvar FSNode = function (parent, name, mode, rdev) {\n  if (!parent) {\n    parent = this;\n  }\n  this.parent = parent;\n  this.mount = parent.mount;\n  this.mounted = null;\n  this.id = FS.nextInode++;\n  this.name = name;\n  this.mode = mode;\n  this.node_ops = {};\n  this.stream_ops = {};\n  this.rdev = rdev;\n};\nvar readMode = 292 | 73;\nvar writeMode = 146;\nObject.defineProperties(FSNode.prototype, {\n  read: {\n    get: function () {\n      return (this.mode & readMode) === readMode;\n    },\n    set: function (val) {\n      val ? this.mode |= readMode : this.mode &= ~readMode;\n    }\n  },\n  write: {\n    get: function () {\n      return (this.mode & writeMode) === writeMode;\n    },\n    set: function (val) {\n      val ? this.mode |= writeMode : this.mode &= ~writeMode;\n    }\n  },\n  isFolder: {\n    get: function () {\n      return FS.isDir(this.mode);\n    }\n  },\n  isDevice: {\n    get: function () {\n      return FS.isChrdev(this.mode);\n    }\n  }\n});\nFS.FSNode = FSNode;\nFS.staticInit();\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\nvar asmLibraryArg = {\n  "o": __ZN7VRegionC1ERK5VRect,\n  "m": __ZN7VRegionD1Ev,\n  "n": __ZN7VRegionpLERK5VRect,\n  "x": __ZNK7VRegion12boundingRectEv,\n  "a": ___assert_fail,\n  "u": ___map_file,\n  "h": ___sys_fcntl64,\n  "z": ___sys_ioctl,\n  "t": ___sys_munmap,\n  "A": ___sys_open,\n  "d": _abort,\n  "c": _emscripten_longjmp,\n  "q": _emscripten_memcpy_big,\n  "r": _emscripten_resize_heap,\n  "v": _environ_get,\n  "w": _environ_sizes_get,\n  "g": _fd_close,\n  "y": _fd_read,\n  "p": _fd_seek,\n  "f": _fd_write,\n  "b": _getTempRet0,\n  "k": invoke_iii,\n  "B": invoke_vi,\n  "memory": wasmMemory,\n  "i": _round,\n  "l": _saveSetjmp,\n  "j": _setTempRet0,\n  "s": _strftime_l,\n  "table": wasmTable,\n  "e": _testSetjmp\n};\nvar asm = createWasm();\nModule["asm"] = asm;\nvar ___wasm_call_ctors = Module["___wasm_call_ctors"] = function () {\n  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["C"]).apply(null, arguments);\n};\nvar _lottie_init = Module["_lottie_init"] = function () {\n  return (_lottie_init = Module["_lottie_init"] = Module["asm"]["D"]).apply(null, arguments);\n};\nvar _lottie_resize = Module["_lottie_resize"] = function () {\n  return (_lottie_resize = Module["_lottie_resize"] = Module["asm"]["E"]).apply(null, arguments);\n};\nvar _free = Module["_free"] = function () {\n  return (_free = Module["_free"] = Module["asm"]["F"]).apply(null, arguments);\n};\nvar _lottie_load_from_data = Module["_lottie_load_from_data"] = function () {\n  return (_lottie_load_from_data = Module["_lottie_load_from_data"] = Module["asm"]["G"]).apply(null, arguments);\n};\nvar _lottie_buffer = Module["_lottie_buffer"] = function () {\n  return (_lottie_buffer = Module["_lottie_buffer"] = Module["asm"]["H"]).apply(null, arguments);\n};\nvar _lottie_destroy = Module["_lottie_destroy"] = function () {\n  return (_lottie_destroy = Module["_lottie_destroy"] = Module["asm"]["I"]).apply(null, arguments);\n};\nvar _lottie_render = Module["_lottie_render"] = function () {\n  return (_lottie_render = Module["_lottie_render"] = Module["asm"]["J"]).apply(null, arguments);\n};\nvar _malloc = Module["_malloc"] = function () {\n  return (_malloc = Module["_malloc"] = Module["asm"]["K"]).apply(null, arguments);\n};\nvar _realloc = Module["_realloc"] = function () {\n  return (_realloc = Module["_realloc"] = Module["asm"]["L"]).apply(null, arguments);\n};\nvar ___errno_location = Module["___errno_location"] = function () {\n  return (___errno_location = Module["___errno_location"] = Module["asm"]["M"]).apply(null, arguments);\n};\nvar _setThrew = Module["_setThrew"] = function () {\n  return (_setThrew = Module["_setThrew"] = Module["asm"]["N"]).apply(null, arguments);\n};\nvar dynCall_vi = Module["dynCall_vi"] = function () {\n  return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["O"]).apply(null, arguments);\n};\nvar dynCall_iii = Module["dynCall_iii"] = function () {\n  return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["P"]).apply(null, arguments);\n};\nvar stackSave = Module["stackSave"] = function () {\n  return (stackSave = Module["stackSave"] = Module["asm"]["Q"]).apply(null, arguments);\n};\nvar stackAlloc = Module["stackAlloc"] = function () {\n  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["R"]).apply(null, arguments);\n};\nvar stackRestore = Module["stackRestore"] = function () {\n  return (stackRestore = Module["stackRestore"] = Module["asm"]["S"]).apply(null, arguments);\n};\nvar dynCall_v = Module["dynCall_v"] = function () {\n  return (dynCall_v = Module["dynCall_v"] = Module["asm"]["T"]).apply(null, arguments);\n};\nfunction invoke_iii(index, a1, a2) {\n  var sp = stackSave();\n  try {\n    return dynCall_iii(index, a1, a2);\n  } catch (e) {\n    stackRestore(sp);\n    if (e !== e + 0 && e !== "longjmp") throw e;\n    _setThrew(1, 0);\n  }\n}\nfunction invoke_vi(index, a1) {\n  var sp = stackSave();\n  try {\n    dynCall_vi(index, a1);\n  } catch (e) {\n    stackRestore(sp);\n    if (e !== e + 0 && e !== "longjmp") throw e;\n    _setThrew(1, 0);\n  }\n}\nModule["asm"] = asm;\nModule["intArrayFromString"] = intArrayFromString;\nModule["cwrap"] = cwrap;\nModule["allocate"] = allocate;\nvar calledRun;\nfunction ExitStatus(status) {\n  this.name = "ExitStatus";\n  this.message = "Program terminated with exit(" + status + ")";\n  this.status = status;\n}\ndependenciesFulfilled = function runCaller() {\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller;\n};\nfunction run(args) {\n  args = args || arguments_;\n  if (runDependencies > 0) {\n    return;\n  }\n  preRun();\n  if (runDependencies > 0) return;\n  function doRun() {\n    if (calledRun) return;\n    calledRun = true;\n    Module["calledRun"] = true;\n    if (ABORT) return;\n    initRuntime();\n    preMain();\n    if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();\n    postRun();\n  }\n  if (Module["setStatus"]) {\n    Module["setStatus"]("Running...");\n    setTimeout(function () {\n      setTimeout(function () {\n        Module["setStatus"]("");\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n}\nModule["run"] = run;\nif (Module["preInit"]) {\n  if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];\n  while (Module["preInit"].length > 0) {\n    Module["preInit"].pop()();\n  }\n}\nnoExitRuntime = true;\nrun();'},37373:(n,e,t)=>{t(69685)(t(42182))}},r={};function a(n){var e=r[n];if(void 0!==e)return e.exports;var o=r[n]={exports:{}};return t[n].call(o.exports,o,o.exports,a),o.exports}a.m=t,a.x=()=>{var n=a.O(void 0,[9070],(()=>a(10289)));return a.O(n)},n=[],a.O=(e,t,r,o)=>{if(!t){var i=1/0;for(l=0;l<n.length;l++){for(var[t,r,o]=n[l],s=!0,u=0;u<t.length;u++)(!1&o||i>=o)&&Object.keys(a.O).every((n=>a.O[n](t[u])))?t.splice(u--,1):(s=!1,o<i&&(i=o));if(s){n.splice(l--,1);var d=r();void 0!==d&&(e=d)}}return e}o=o||0;for(var l=n.length;l>0&&n[l-1][2]>o;l--)n[l]=n[l-1];n[l]=[t,r,o]},a.f={},a.e=n=>Promise.all(Object.keys(a.f).reduce(((e,t)=>(a.f[t](n,e),e)),[])),a.u=n=>n+".80a89a88a1fc47a1997f.js",a.miniCssF=n=>{},a.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),a.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),(()=>{var n;a.g.importScripts&&(n=a.g.location+"");var e=a.g.document;if(!n&&e&&(e.currentScript&&(n=e.currentScript.src),!n)){var t=e.getElementsByTagName("script");t.length&&(n=t[t.length-1].src)}if(!n)throw new Error("Automatic publicPath is not supported in this browser");n=n.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),a.p=n})(),(()=>{var n={289:1};a.f.i=(e,t)=>{n[e]||importScripts(a.p+a.u(e))};var e=self.webpackChunkwai=self.webpackChunkwai||[],t=e.push.bind(e);e.push=e=>{var[r,o,i]=e;for(var s in o)a.o(o,s)&&(a.m[s]=o[s]);for(i&&i(a);r.length;)n[r.pop()]=1;t(e)}})(),e=a.x,a.x=()=>a.e(9070).then(e),a.x()})();
//# sourceMappingURL=289.15d19b40b1309c97a03b.js.map