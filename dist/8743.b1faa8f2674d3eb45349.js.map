{"version":3,"file":"8743.b1faa8f2674d3eb45349.js","mappings":"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","sources":["webpack://wai/./src/lib/gramjs/Helpers.js","webpack://wai/./src/lib/gramjs/crypto/converters.ts","webpack://wai/./src/lib/gramjs/crypto/crypto.js","webpack://wai/./src/lib/gramjs/crypto/words.ts"],"sourcesContent":["const BigInt = require('big-integer');\nconst crypto = require('./crypto/crypto');\n\n/**\n * converts a buffer to big int\n * @param buffer\n * @param little\n * @param signed\n * @returns {bigInt.BigInteger}\n */\nfunction readBigIntFromBuffer(buffer, little = true, signed = false) {\n    let randBuffer = Buffer.from(buffer);\n    const bytesNumber = randBuffer.length;\n    if (little) {\n        randBuffer = randBuffer.reverse();\n    }\n    let bigInt = BigInt(randBuffer.toString('hex'), 16);\n    if (signed && Math.floor(bigInt.toString('2').length / 8) >= bytesNumber) {\n        bigInt = bigInt.subtract(BigInt(2)\n            .pow(BigInt(bytesNumber * 8)));\n    }\n    return bigInt;\n}\n\n/**\n * Special case signed little ints\n * @param big\n * @param number\n * @returns {Buffer}\n */\nfunction toSignedLittleBuffer(big, number = 8) {\n    const bigNumber = BigInt(big);\n    const byteArray = [];\n    for (let i = 0; i < number; i++) {\n        byteArray[i] = bigNumber.shiftRight(8 * i)\n            .and(255);\n    }\n    return Buffer.from(byteArray);\n}\n\n/**\n * converts a big int to a buffer\n * @param bigInt {bigInt.BigInteger}\n * @param bytesNumber\n * @param little\n * @param signed\n * @returns {Buffer}\n */\nfunction readBufferFromBigInt(bigInt, bytesNumber, little = true, signed = false) {\n    bigInt = BigInt(bigInt);\n    const bitLength = bigInt.bitLength();\n\n    const bytes = Math.ceil(bitLength / 8);\n    if (bytesNumber < bytes) {\n        throw new Error('OverflowError: int too big to convert');\n    }\n    if (!signed && bigInt.lesser(BigInt(0))) {\n        throw new Error('Cannot convert to unsigned');\n    }\n    let below = false;\n    if (bigInt.lesser(BigInt(0))) {\n        below = true;\n        bigInt = bigInt.abs();\n    }\n\n    const hex = bigInt.toString('16')\n        .padStart(bytesNumber * 2, '0');\n    let l = Buffer.from(hex, 'hex');\n    if (little) {\n        l = l.reverse();\n    }\n\n    if (signed && below) {\n        if (little) {\n            let reminder = false;\n            if (l[0] !== 0) {\n                l[0] -= 1;\n            }\n            for (let i = 0; i < l.length; i++) {\n                if (l[i] === 0) {\n                    reminder = true;\n                    continue;\n                }\n                if (reminder) {\n                    l[i] -= 1;\n                    reminder = false;\n                }\n                l[i] = 255 - l[i];\n            }\n        } else {\n            l[l.length - 1] = 256 - l[l.length - 1];\n            for (let i = 0; i < l.length - 1; i++) {\n                l[i] = 255 - l[i];\n            }\n        }\n    }\n    return l;\n}\n\n/**\n * Generates a random long integer (8 bytes), which is optionally signed\n * @returns {BigInteger}\n */\nfunction generateRandomLong(signed = true) {\n    return readBigIntFromBuffer(generateRandomBytes(8), true, signed);\n}\n\n/**\n * .... really javascript\n * @param n {number}\n * @param m {number}\n * @returns {number}\n */\nfunction mod(n, m) {\n    return ((n % m) + m) % m;\n}\n\n/**\n * returns a positive bigInt\n * @param n {BigInt}\n * @param m {BigInt}\n * @returns {BigInt}\n */\nfunction bigIntMod(n, m) {\n    return ((n.remainder(m)).add(m)).remainder(m);\n}\n\n/**\n * Generates a random bytes array\n * @param count\n * @returns {Buffer}\n */\nfunction generateRandomBytes(count) {\n    return Buffer.from(crypto.randomBytes(count));\n}\n\n/**\n * Calculate the key based on Telegram guidelines, specifying whether it's the client or not\n * @param sharedKey\n * @param msgKey\n * @param client\n * @returns {{iv: Buffer, key: Buffer}}\n */\n\n/* CONTEST\nthis is mtproto 1 (mostly used for secret chats)\nasync function calcKey(sharedKey, msgKey, client) {\n    const x = client === true ? 0 : 8\n    const [sha1a, sha1b, sha1c, sha1d] = await Promise.all([\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x, x + 32)])),\n        sha1(Buffer.concat([sharedKey.slice(x + 32, x + 48), msgKey, sharedKey.slice(x + 48, x + 64)])),\n        sha1(Buffer.concat([sharedKey.slice(x + 64, x + 96), msgKey])),\n        sha1(Buffer.concat([msgKey, sharedKey.slice(x + 96, x + 128)]))\n    ])\n    const key = Buffer.concat([sha1a.slice(0, 8), sha1b.slice(8, 20), sha1c.slice(4, 16)])\n    const iv = Buffer.concat([sha1a.slice(8, 20), sha1b.slice(0, 8), sha1c.slice(16, 20), sha1d.slice(0, 8)])\n    return {\n        key,\n        iv\n    }\n}\n\n */\n\n/**\n * Generates the key data corresponding to the given nonces\n * @param serverNonce\n * @param newNonce\n * @returns {{key: Buffer, iv: Buffer}}\n */\nasync function generateKeyDataFromNonce(serverNonce, newNonce) {\n    serverNonce = toSignedLittleBuffer(serverNonce, 16);\n    newNonce = toSignedLittleBuffer(newNonce, 32);\n    const [hash1, hash2, hash3] = await Promise.all([\n        sha1(Buffer.concat([newNonce, serverNonce])),\n        sha1(Buffer.concat([serverNonce, newNonce])),\n        sha1(Buffer.concat([newNonce, newNonce])),\n    ]);\n    const keyBuffer = Buffer.concat([hash1, hash2.slice(0, 12)]);\n    const ivBuffer = Buffer.concat([hash2.slice(12, 20), hash3, newNonce.slice(0, 4)]);\n    return {\n        key: keyBuffer,\n        iv: ivBuffer,\n    };\n}\n\nfunction convertToLittle(buf) {\n    const correct = Buffer.alloc(buf.length * 4);\n\n    for (let i = 0; i < buf.length; i++) {\n        correct.writeUInt32BE(buf[i], i * 4);\n    }\n    return correct;\n}\n\n/**\n * Calculates the SHA1 digest for the given data\n * @param data\n * @returns {Promise}\n */\nfunction sha1(data) {\n    const shaSum = crypto.createHash('sha1');\n    shaSum.update(data);\n    return shaSum.digest();\n}\n\n/**\n * Calculates the SHA256 digest for the given data\n * @param data\n * @returns {Promise}\n */\nfunction sha256(data) {\n    const shaSum = crypto.createHash('sha256');\n    shaSum.update(data);\n    return shaSum.digest();\n}\n\n/**\n * Fast mod pow for RSA calculation. a^b % n\n * @param a\n * @param b\n * @param n\n * @returns {bigInt.BigInteger}\n */\nfunction modExp(a, b, n) {\n    a = a.remainder(n);\n    let result = BigInt.one;\n    let x = a;\n    while (b.greater(BigInt.zero)) {\n        const leastSignificantBit = b.remainder(BigInt(2));\n        b = b.divide(BigInt(2));\n        if (leastSignificantBit.eq(BigInt.one)) {\n            result = result.multiply(x);\n            result = result.remainder(n);\n        }\n        x = x.multiply(x);\n        x = x.remainder(n);\n    }\n    return result;\n}\n\n/**\n * Gets the arbitrary-length byte array corresponding to the given integer\n * @param integer {any}\n * @param signed {boolean}\n * @returns {Buffer}\n */\nfunction getByteArray(integer, signed = false) {\n    const bits = integer.toString(2).length;\n    const byteLength = Math.floor((bits + 8 - 1) / 8);\n    return readBufferFromBigInt(BigInt(integer), byteLength, false, signed);\n}\n\n/**\n * returns a random int from min (inclusive) and max (inclusive)\n * @param min\n * @param max\n * @returns {number}\n */\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/**\n * Sleeps a specified amount of time\n * @param ms time in milliseconds\n * @returns {Promise}\n */\nconst sleep = (ms) => new Promise((resolve) => {\n    setTimeout(resolve, ms);\n});\n\n/**\n * Helper to export two buffers of same length\n * @returns {Buffer}\n */\n\nfunction bufferXor(a, b) {\n    const res = [];\n    for (let i = 0; i < a.length; i++) {\n        res.push(a[i] ^ b[i]);\n    }\n    return Buffer.from(res);\n}\n\n/**\n * Checks if the obj is an array\n * @param obj\n * @returns {boolean}\n */\n/*\nCONTEST\nwe do'nt support array requests anyway\nfunction isArrayLike(obj) {\n    if (!obj) return false\n    const l = obj.length\n    if (typeof l != 'number' || l < 0) return false\n    if (Math.floor(l) !== l) return false\n    // fast check\n    if (l > 0 && !(l - 1 in obj)) return false\n    // more complete check (optional)\n    for (let i = 0; i < l; ++i) {\n        if (!(i in obj)) return false\n    }\n    return true\n}\n*/\n\n// Taken from https://stackoverflow.com/questions/18638900/javascript-crc32/18639999#18639999\nfunction makeCRCTable() {\n    let c;\n    const crcTable = [];\n    for (let n = 0; n < 256; n++) {\n        c = n;\n        for (let k = 0; k < 8; k++) {\n            c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n        }\n        crcTable[n] = c;\n    }\n    return crcTable;\n}\n\nlet crcTable;\n\nfunction crc32(buf) {\n    if (!crcTable) {\n        crcTable = makeCRCTable();\n    }\n    if (!Buffer.isBuffer(buf)) {\n        buf = Buffer.from(buf);\n    }\n    let crc = -1;\n\n    for (let index = 0; index < buf.length; index++) {\n        const byte = buf[index];\n        crc = crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);\n    }\n    return (crc ^ (-1)) >>> 0;\n}\n\nmodule.exports = {\n    readBigIntFromBuffer,\n    readBufferFromBigInt,\n    generateRandomLong,\n    mod,\n    crc32,\n    generateRandomBytes,\n    // calcKey,\n    generateKeyDataFromNonce,\n    sha1,\n    sha256,\n    bigIntMod,\n    modExp,\n    getRandomInt,\n    sleep,\n    getByteArray,\n    // isArrayLike,\n    toSignedLittleBuffer,\n    convertToLittle,\n    bufferXor,\n};\n","/**\n * Uint32Array -> ArrayBuffer (low-endian os)\n */\nexport function i2abLow(buf: Uint32Array): ArrayBuffer {\n    const uint8 = new Uint8Array(buf.length * 4);\n    let i = 0;\n\n    for (let j = 0; j < buf.length; j++) {\n        const int = buf[j];\n\n        uint8[i++] = int >>> 24;\n        uint8[i++] = (int >> 16) & 0xFF;\n        uint8[i++] = (int >> 8) & 0xFF;\n        uint8[i++] = int & 0xFF;\n    }\n\n    return uint8.buffer;\n}\n\n/**\n * Uint32Array -> ArrayBuffer (big-endian os)\n */\nexport function i2abBig(buf: Uint32Array): ArrayBuffer {\n    return buf.buffer;\n}\n\n/**\n * ArrayBuffer -> Uint32Array (low-endian os)\n */\nexport function ab2iLow(ab: ArrayBuffer | SharedArrayBuffer | Uint8Array): Uint32Array {\n    const uint8 = new Uint8Array(ab);\n    const buf = new Uint32Array(uint8.length / 4);\n\n    for (let i = 0; i < uint8.length; i += 4) {\n        buf[i / 4] = (\n            uint8[i] << 24\n            ^ uint8[i + 1] << 16\n            ^ uint8[i + 2] << 8\n            ^ uint8[i + 3]\n        );\n    }\n\n    return buf;\n}\n\n/**\n * ArrayBuffer -> Uint32Array (big-endian os)\n */\nexport function ab2iBig(ab: ArrayBuffer | SharedArrayBuffer | Uint8Array): Uint32Array {\n    return new Uint32Array(ab);\n}\n\nexport const isBigEndian = new Uint8Array(new Uint32Array([0x01020304]))[0] === 0x01;\nexport const i2ab = isBigEndian ? i2abBig : i2abLow;\nexport const ab2i = isBigEndian ? ab2iBig : ab2iLow;\n","const AES = require('@cryptography/aes').default;\nconst {\n    i2ab,\n    ab2i,\n} = require('./converters');\nconst { getWords } = require('./words');\n\nclass Counter {\n    constructor(initialValue) {\n        this.setBytes(initialValue);\n    }\n\n    setBytes(bytes) {\n        bytes = Buffer.from(bytes);\n        this._counter = bytes;\n    }\n\n    increment() {\n        for (let i = 15; i >= 0; i--) {\n            if (this._counter[i] === 255) {\n                this._counter[i] = 0;\n            } else {\n                this._counter[i]++;\n                break;\n            }\n        }\n    }\n}\n\nclass CTR {\n    constructor(key, counter) {\n        if (!(counter instanceof Counter)) {\n            counter = new Counter(counter);\n        }\n\n        this._counter = counter;\n\n        this._remainingCounter = undefined;\n        this._remainingCounterIndex = 16;\n\n        this._aes = new AES(getWords(key));\n    }\n\n    update(plainText) {\n        return this.encrypt(plainText);\n    }\n\n    encrypt(plainText) {\n        const encrypted = Buffer.from(plainText);\n\n        for (let i = 0; i < encrypted.length; i++) {\n            if (this._remainingCounterIndex === 16) {\n                this._remainingCounter = Buffer.from(i2ab(this._aes.encrypt(ab2i(this._counter._counter))));\n                this._remainingCounterIndex = 0;\n                this._counter.increment();\n            }\n            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];\n        }\n\n        return encrypted;\n    }\n}\n\n// endregion\nfunction createDecipheriv(algorithm, key, iv) {\n    if (algorithm.includes('ECB')) {\n        throw new Error('Not supported');\n    } else {\n        return new CTR(key, iv);\n    }\n}\n\nfunction createCipheriv(algorithm, key, iv) {\n    if (algorithm.includes('ECB')) {\n        throw new Error('Not supported');\n    } else {\n        return new CTR(key, iv);\n    }\n}\n\nfunction randomBytes(count) {\n    const bytes = new Uint8Array(count);\n    crypto.getRandomValues(bytes);\n    return bytes;\n}\n\nclass Hash {\n    constructor(algorithm) {\n        this.algorithm = algorithm;\n    }\n\n    update(data) {\n        // We shouldn't be needing new Uint8Array but it doesn't\n        // work without it\n        this.data = new Uint8Array(data);\n    }\n\n    async digest() {\n        if (this.algorithm === 'sha1') {\n            // eslint-disable-next-line no-restricted-globals\n            return Buffer.from(await self.crypto.subtle.digest('SHA-1', this.data));\n        } else if (this.algorithm === 'sha256') {\n            // eslint-disable-next-line no-restricted-globals\n            return Buffer.from(await self.crypto.subtle.digest('SHA-256', this.data));\n        }\n        return undefined;\n    }\n}\n\nasync function pbkdf2(password, salt, iterations) {\n    const passwordKey = await crypto.subtle.importKey('raw', password, { name: 'PBKDF2' }, false, ['deriveBits']);\n    return Buffer.from(await crypto.subtle.deriveBits({\n        name: 'PBKDF2',\n        hash: 'SHA-512',\n        salt,\n        iterations,\n    }, passwordKey, 512));\n}\n\nfunction createHash(algorithm) {\n    return new Hash(algorithm);\n}\n\nmodule.exports = {\n    createCipheriv,\n    createDecipheriv,\n    randomBytes,\n    createHash,\n    pbkdf2,\n};\n","/*\n * Imported from https://github.com/spalt08/cryptography/blob/master/packages/aes/src/utils/words.ts\n */\n\nexport function s2i(str: string, pos: number) {\n    return (\n        str.charCodeAt(pos) << 24\n        ^ str.charCodeAt(pos + 1) << 16\n        ^ str.charCodeAt(pos + 2) << 8\n        ^ str.charCodeAt(pos + 3)\n    );\n}\n\n/**\n * Helper function for transforming string key to Uint32Array\n */\nexport function getWords(key: string | Uint8Array | Uint32Array) {\n    if (key instanceof Uint32Array) {\n        return key;\n    }\n\n    if (typeof key === 'string') {\n        if (key.length % 4 !== 0) for (let i = key.length % 4; i <= 4; i++) key += '\\0x00';\n\n        const buf = new Uint32Array(key.length / 4);\n        for (let i = 0; i < key.length; i += 4) buf[i / 4] = s2i(key, i);\n\n        return buf;\n    }\n\n    if (key instanceof Uint8Array) {\n        const buf = new Uint32Array(key.length / 4);\n\n        for (let i = 0; i < key.length; i += 4) {\n            buf[i / 4] = (\n                key[i] << 24\n                ^ key[i + 1] << 16\n                ^ key[i + 2] << 8\n                ^ key[i + 3]\n            );\n        }\n\n        return buf;\n    }\n\n    throw new Error('Unable to create 32-bit words');\n}\n\nexport function xor(left: Uint32Array, right: Uint32Array, to = left) {\n    for (let i = 0; i < left.length; i++) to[i] = left[i] ^ right[i];\n}\n"],"names":["BigInt","require","crypto","readBigIntFromBuffer","buffer","little","signed","randBuffer","Buffer","from","bytesNumber","length","reverse","bigInt","toString","Math","floor","subtract","pow","toSignedLittleBuffer","big","number","bigNumber","byteArray","i","shiftRight","and","readBufferFromBigInt","bitLength","ceil","Error","lesser","below","abs","hex","padStart","l","reminder","generateRandomBytes","count","randomBytes","sha1","data","shaSum","createHash","update","digest","crcTable","module","exports","generateRandomLong","mod","n","m","crc32","buf","c","k","makeCRCTable","isBuffer","crc","index","byte","generateKeyDataFromNonce","async","serverNonce","newNonce","hash1","hash2","hash3","Promise","all","concat","key","slice","iv","sha256","bigIntMod","remainder","add","modExp","a","b","result","one","x","greater","zero","leastSignificantBit","divide","eq","multiply","getRandomInt","min","max","random","sleep","ms","resolve","setTimeout","getByteArray","integer","bits","byteLength","convertToLittle","correct","alloc","writeUInt32BE","bufferXor","res","push","i2abLow","uint8","Uint8Array","j","int","i2abBig","ab2iLow","ab","Uint32Array","ab2iBig","isBigEndian","i2ab","ab2i","AES","getWords","Counter","constructor","initialValue","this","setBytes","bytes","_counter","increment","CTR","counter","_remainingCounter","undefined","_remainingCounterIndex","_aes","plainText","encrypt","encrypted","Hash","algorithm","self","subtle","createCipheriv","includes","createDecipheriv","getRandomValues","pbkdf2","password","salt","iterations","passwordKey","importKey","name","deriveBits","hash","s2i","str","pos","charCodeAt","xor","left","right","to"],"sourceRoot":""}